{"version":3,"file":"syntax.js","sources":["../../../node_modules/micromark-extension-gfm-strikethrough/lib/syntax.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').Event} Event\n */\n\n/**\n * @typedef Options\n * @property {boolean} [singleTilde=true]\n *   Whether to support strikethrough with a single tilde (`boolean`, default:\n *   `true`).\n *   Single tildes work on github.com, but are technically prohibited by the\n *   GFM spec.\n */\nimport {splice} from 'micromark-util-chunked'\nimport {classifyCharacter} from 'micromark-util-classify-character'\nimport {resolveAll} from 'micromark-util-resolve-all'\n\n/**\n * @param {Options} [options]\n * @returns {Extension}\n */\nexport function gfmStrikethrough(options = {}) {\n  let single = options.singleTilde\n  const tokenizer = {\n    tokenize: tokenizeStrikethrough,\n    resolveAll: resolveAllStrikethrough\n  }\n\n  if (single === null || single === undefined) {\n    single = true\n  }\n\n  return {\n    text: {\n      [126]: tokenizer\n    },\n    insideSpan: {\n      null: [tokenizer]\n    },\n    attentionMarkers: {\n      null: [126]\n    }\n  }\n  /**\n   * Take events and resolve strikethrough.\n   *\n   * @type {Resolver}\n   */\n\n  function resolveAllStrikethrough(events, context) {\n    let index = -1 // Walk through all events.\n\n    while (++index < events.length) {\n      // Find a token that can close.\n      if (\n        events[index][0] === 'enter' &&\n        events[index][1].type === 'strikethroughSequenceTemporary' &&\n        events[index][1]._close\n      ) {\n        let open = index // Now walk back to find an opener.\n\n        while (open--) {\n          // Find a token that can open the closer.\n          if (\n            events[open][0] === 'exit' &&\n            events[open][1].type === 'strikethroughSequenceTemporary' &&\n            events[open][1]._open && // If the sizes are the same:\n            events[index][1].end.offset - events[index][1].start.offset ===\n              events[open][1].end.offset - events[open][1].start.offset\n          ) {\n            events[index][1].type = 'strikethroughSequence'\n            events[open][1].type = 'strikethroughSequence'\n            const strikethrough = {\n              type: 'strikethrough',\n              start: Object.assign({}, events[open][1].start),\n              end: Object.assign({}, events[index][1].end)\n            }\n            const text = {\n              type: 'strikethroughText',\n              start: Object.assign({}, events[open][1].end),\n              end: Object.assign({}, events[index][1].start)\n            } // Opening.\n\n            const nextEvents = [\n              ['enter', strikethrough, context],\n              ['enter', events[open][1], context],\n              ['exit', events[open][1], context],\n              ['enter', text, context]\n            ] // Between.\n\n            splice(\n              nextEvents,\n              nextEvents.length,\n              0,\n              resolveAll(\n                context.parser.constructs.insideSpan.null,\n                events.slice(open + 1, index),\n                context\n              )\n            ) // Closing.\n\n            splice(nextEvents, nextEvents.length, 0, [\n              ['exit', text, context],\n              ['enter', events[index][1], context],\n              ['exit', events[index][1], context],\n              ['exit', strikethrough, context]\n            ])\n            splice(events, open - 1, index - open + 3, nextEvents)\n            index = open + nextEvents.length - 2\n            break\n          }\n        }\n      }\n    }\n\n    index = -1\n\n    while (++index < events.length) {\n      if (events[index][1].type === 'strikethroughSequenceTemporary') {\n        events[index][1].type = 'data'\n      }\n    }\n\n    return events\n  }\n  /** @type {Tokenizer} */\n\n  function tokenizeStrikethrough(effects, ok, nok) {\n    const previous = this.previous\n    const events = this.events\n    let size = 0\n    return start\n    /** @type {State} */\n\n    function start(code) {\n      if (\n        previous === 126 &&\n        events[events.length - 1][1].type !== 'characterEscape'\n      ) {\n        return nok(code)\n      }\n\n      effects.enter('strikethroughSequenceTemporary')\n      return more(code)\n    }\n    /** @type {State} */\n\n    function more(code) {\n      const before = classifyCharacter(previous)\n\n      if (code === 126) {\n        // If this is the third marker, exit.\n        if (size > 1) return nok(code)\n        effects.consume(code)\n        size++\n        return more\n      }\n\n      if (size < 2 && !single) return nok(code)\n      const token = effects.exit('strikethroughSequenceTemporary')\n      const after = classifyCharacter(code)\n      token._open = !after || (after === 2 && Boolean(before))\n      token._close = !before || (before === 2 && Boolean(after))\n      return ok(code)\n    }\n  }\n}\n"],"names":["options","single","singleTilde","tokenizer","tokenize","effects","ok","nok","previous","this","events","size","code","length","type","enter","more","before","classifyCharacter","consume","token","exit","after","_open","Boolean","_close","resolveAll","context","index","open","end","offset","start","strikethrough","Object","assign","text","nextEvents","splice","parser","constructs","insideSpan","null","slice","attentionMarkers"],"mappings":"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"}