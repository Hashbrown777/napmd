{"version":3,"file":"code-fenced.js","sources":["../../../node_modules/micromark-core-commonmark/lib/code-fenced.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Code} Code\n */\nimport {factorySpace} from 'micromark-factory-space'\nimport {\n  markdownLineEnding,\n  markdownLineEndingOrSpace\n} from 'micromark-util-character'\n\n/** @type {Construct} */\nexport const codeFenced = {\n  name: 'codeFenced',\n  tokenize: tokenizeCodeFenced,\n  concrete: true\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeCodeFenced(effects, ok, nok) {\n  const self = this\n  /** @type {Construct} */\n\n  const closingFenceConstruct = {\n    tokenize: tokenizeClosingFence,\n    partial: true\n  }\n  /** @type {Construct} */\n\n  const nonLazyLine = {\n    tokenize: tokenizeNonLazyLine,\n    partial: true\n  }\n  const tail = this.events[this.events.length - 1]\n  const initialPrefix =\n    tail && tail[1].type === 'linePrefix'\n      ? tail[2].sliceSerialize(tail[1], true).length\n      : 0\n  let sizeOpen = 0\n  /** @type {NonNullable<Code>} */\n\n  let marker\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('codeFenced')\n    effects.enter('codeFencedFence')\n    effects.enter('codeFencedFenceSequence')\n    marker = code\n    return sequenceOpen(code)\n  }\n  /** @type {State} */\n\n  function sequenceOpen(code) {\n    if (code === marker) {\n      effects.consume(code)\n      sizeOpen++\n      return sequenceOpen\n    }\n\n    effects.exit('codeFencedFenceSequence')\n    return sizeOpen < 3\n      ? nok(code)\n      : factorySpace(effects, infoOpen, 'whitespace')(code)\n  }\n  /** @type {State} */\n\n  function infoOpen(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return openAfter(code)\n    }\n\n    effects.enter('codeFencedFenceInfo')\n    effects.enter('chunkString', {\n      contentType: 'string'\n    })\n    return info(code)\n  }\n  /** @type {State} */\n\n  function info(code) {\n    if (code === null || markdownLineEndingOrSpace(code)) {\n      effects.exit('chunkString')\n      effects.exit('codeFencedFenceInfo')\n      return factorySpace(effects, infoAfter, 'whitespace')(code)\n    }\n\n    if (code === 96 && code === marker) return nok(code)\n    effects.consume(code)\n    return info\n  }\n  /** @type {State} */\n\n  function infoAfter(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return openAfter(code)\n    }\n\n    effects.enter('codeFencedFenceMeta')\n    effects.enter('chunkString', {\n      contentType: 'string'\n    })\n    return meta(code)\n  }\n  /** @type {State} */\n\n  function meta(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('chunkString')\n      effects.exit('codeFencedFenceMeta')\n      return openAfter(code)\n    }\n\n    if (code === 96 && code === marker) return nok(code)\n    effects.consume(code)\n    return meta\n  }\n  /** @type {State} */\n\n  function openAfter(code) {\n    effects.exit('codeFencedFence')\n    return self.interrupt ? ok(code) : contentStart(code)\n  }\n  /** @type {State} */\n\n  function contentStart(code) {\n    if (code === null) {\n      return after(code)\n    }\n\n    if (markdownLineEnding(code)) {\n      return effects.attempt(\n        nonLazyLine,\n        effects.attempt(\n          closingFenceConstruct,\n          after,\n          initialPrefix\n            ? factorySpace(\n                effects,\n                contentStart,\n                'linePrefix',\n                initialPrefix + 1\n              )\n            : contentStart\n        ),\n        after\n      )(code)\n    }\n\n    effects.enter('codeFlowValue')\n    return contentContinue(code)\n  }\n  /** @type {State} */\n\n  function contentContinue(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('codeFlowValue')\n      return contentStart(code)\n    }\n\n    effects.consume(code)\n    return contentContinue\n  }\n  /** @type {State} */\n\n  function after(code) {\n    effects.exit('codeFenced')\n    return ok(code)\n  }\n  /** @type {Tokenizer} */\n\n  function tokenizeNonLazyLine(effects, ok, nok) {\n    const self = this\n    return start\n    /** @type {State} */\n\n    function start(code) {\n      effects.enter('lineEnding')\n      effects.consume(code)\n      effects.exit('lineEnding')\n      return lineStart\n    }\n    /** @type {State} */\n\n    function lineStart(code) {\n      return self.parser.lazy[self.now().line] ? nok(code) : ok(code)\n    }\n  }\n  /** @type {Tokenizer} */\n\n  function tokenizeClosingFence(effects, ok, nok) {\n    let size = 0\n    return factorySpace(\n      effects,\n      closingSequenceStart,\n      'linePrefix',\n      this.parser.constructs.disable.null.includes('codeIndented')\n        ? undefined\n        : 4\n    )\n    /** @type {State} */\n\n    function closingSequenceStart(code) {\n      effects.enter('codeFencedFence')\n      effects.enter('codeFencedFenceSequence')\n      return closingSequence(code)\n    }\n    /** @type {State} */\n\n    function closingSequence(code) {\n      if (code === marker) {\n        effects.consume(code)\n        size++\n        return closingSequence\n      }\n\n      if (size < sizeOpen) return nok(code)\n      effects.exit('codeFencedFenceSequence')\n      return factorySpace(effects, closingSequenceEnd, 'whitespace')(code)\n    }\n    /** @type {State} */\n\n    function closingSequenceEnd(code) {\n      if (code === null || markdownLineEnding(code)) {\n        effects.exit('codeFencedFence')\n        return ok(code)\n      }\n\n      return nok(code)\n    }\n  }\n}\n"],"names":["codeFenced","name","tokenize","effects","ok","nok","self","this","closingFenceConstruct","size","factorySpace","closingSequenceStart","parser","constructs","disable","null","includes","undefined","code","enter","closingSequence","marker","consume","sizeOpen","exit","closingSequenceEnd","markdownLineEnding","partial","nonLazyLine","start","lineStart","lazy","now","line","tail","events","length","initialPrefix","type","sliceSerialize","sequenceOpen","infoOpen","openAfter","contentType","info","markdownLineEndingOrSpace","infoAfter","meta","interrupt","contentStart","after","attempt","contentContinue","concrete"],"mappings":"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"}