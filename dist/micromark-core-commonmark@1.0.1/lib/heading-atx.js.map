{"version":3,"file":"heading-atx.js","sources":["../../../node_modules/micromark-core-commonmark/lib/heading-atx.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').State} State\n */\nimport {factorySpace} from 'micromark-factory-space'\nimport {\n  markdownLineEnding,\n  markdownLineEndingOrSpace,\n  markdownSpace\n} from 'micromark-util-character'\nimport {splice} from 'micromark-util-chunked'\n\n/** @type {Construct} */\nexport const headingAtx = {\n  name: 'headingAtx',\n  tokenize: tokenizeHeadingAtx,\n  resolve: resolveHeadingAtx\n}\n/** @type {Resolver} */\n\nfunction resolveHeadingAtx(events, context) {\n  let contentEnd = events.length - 2\n  let contentStart = 3\n  /** @type {Token} */\n\n  let content\n  /** @type {Token} */\n\n  let text // Prefix whitespace, part of the opening.\n\n  if (events[contentStart][1].type === 'whitespace') {\n    contentStart += 2\n  } // Suffix whitespace, part of the closing.\n\n  if (\n    contentEnd - 2 > contentStart &&\n    events[contentEnd][1].type === 'whitespace'\n  ) {\n    contentEnd -= 2\n  }\n\n  if (\n    events[contentEnd][1].type === 'atxHeadingSequence' &&\n    (contentStart === contentEnd - 1 ||\n      (contentEnd - 4 > contentStart &&\n        events[contentEnd - 2][1].type === 'whitespace'))\n  ) {\n    contentEnd -= contentStart + 1 === contentEnd ? 2 : 4\n  }\n\n  if (contentEnd > contentStart) {\n    content = {\n      type: 'atxHeadingText',\n      start: events[contentStart][1].start,\n      end: events[contentEnd][1].end\n    }\n    text = {\n      type: 'chunkText',\n      start: events[contentStart][1].start,\n      end: events[contentEnd][1].end,\n      // @ts-expect-error Constants are fine to assign.\n      contentType: 'text'\n    }\n    splice(events, contentStart, contentEnd - contentStart + 1, [\n      ['enter', content, context],\n      ['enter', text, context],\n      ['exit', text, context],\n      ['exit', content, context]\n    ])\n  }\n\n  return events\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeHeadingAtx(effects, ok, nok) {\n  const self = this\n  let size = 0\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('atxHeading')\n    effects.enter('atxHeadingSequence')\n    return fenceOpenInside(code)\n  }\n  /** @type {State} */\n\n  function fenceOpenInside(code) {\n    if (code === 35 && size++ < 6) {\n      effects.consume(code)\n      return fenceOpenInside\n    }\n\n    if (code === null || markdownLineEndingOrSpace(code)) {\n      effects.exit('atxHeadingSequence')\n      return self.interrupt ? ok(code) : headingBreak(code)\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function headingBreak(code) {\n    if (code === 35) {\n      effects.enter('atxHeadingSequence')\n      return sequence(code)\n    }\n\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('atxHeading')\n      return ok(code)\n    }\n\n    if (markdownSpace(code)) {\n      return factorySpace(effects, headingBreak, 'whitespace')(code)\n    }\n\n    effects.enter('atxHeadingText')\n    return data(code)\n  }\n  /** @type {State} */\n\n  function sequence(code) {\n    if (code === 35) {\n      effects.consume(code)\n      return sequence\n    }\n\n    effects.exit('atxHeadingSequence')\n    return headingBreak(code)\n  }\n  /** @type {State} */\n\n  function data(code) {\n    if (code === null || code === 35 || markdownLineEndingOrSpace(code)) {\n      effects.exit('atxHeadingText')\n      return headingBreak(code)\n    }\n\n    effects.consume(code)\n    return data\n  }\n}\n"],"names":["headingAtx","name","tokenize","effects","ok","nok","self","this","size","code","enter","fenceOpenInside","consume","markdownLineEndingOrSpace","exit","interrupt","headingBreak","sequence","markdownLineEnding","markdownSpace","factorySpace","data","resolve","events","context","content","text","contentEnd","length","contentStart","type","start","end","contentType","splice"],"mappings":"0HAgBaA,EAAa,CACxBC,KAAM,aACNC,SA4DF,SAA4BC,EAASC,EAAIC,GACvC,MAAMC,EAAOC,KACb,IAAIC,EAAO,EACX,OAGA,SAAeC,GAGb,OAFAN,EAAQO,MAAM,cACdP,EAAQO,MAAM,sBACPC,EAAgBF,IAIzB,SAASE,EAAgBF,GACvB,OAAa,KAATA,GAAeD,IAAS,GAC1BL,EAAQS,QAAQH,GACTE,GAGI,OAATF,GAAiBI,4BAA0BJ,IAC7CN,EAAQW,KAAK,sBACNR,EAAKS,UAAYX,EAAGK,GAAQO,EAAaP,IAG3CJ,EAAII,GAIb,SAASO,EAAaP,GACpB,OAAa,KAATA,GACFN,EAAQO,MAAM,sBACPO,EAASR,IAGL,OAATA,GAAiBS,qBAAmBT,IACtCN,EAAQW,KAAK,cACNV,EAAGK,IAGRU,gBAAcV,GACTW,eAAajB,EAASa,EAAc,aAApCI,CAAkDX,IAG3DN,EAAQO,MAAM,kBACPW,EAAKZ,IAId,SAASQ,EAASR,GAChB,OAAa,KAATA,GACFN,EAAQS,QAAQH,GACTQ,IAGTd,EAAQW,KAAK,sBACNE,EAAaP,IAItB,SAASY,EAAKZ,GACZ,OAAa,OAATA,GAA0B,KAATA,GAAeI,4BAA0BJ,IAC5DN,EAAQW,KAAK,kBACNE,EAAaP,KAGtBN,EAAQS,QAAQH,GACTY,KA7HTC,QAIF,SAA2BC,EAAQC,GACjC,IAIIC,EAGAC,EAPAC,EAAaJ,EAAOK,OAAS,EAC7BC,EAAe,EAQkB,eAAjCN,EAAOM,GAAc,GAAGC,OAC1BD,GAAgB,GAIhBF,EAAa,EAAIE,GACc,eAA/BN,EAAOI,GAAY,GAAGG,OAEtBH,GAAc,GAIiB,uBAA/BJ,EAAOI,GAAY,GAAGG,OACrBD,IAAiBF,EAAa,GAC5BA,EAAa,EAAIE,GACmB,eAAnCN,EAAOI,EAAa,GAAG,GAAGG,QAE9BH,GAAcE,EAAe,IAAMF,EAAa,EAAI,GAGlDA,EAAaE,IACfJ,EAAU,CACRK,KAAM,iBACNC,MAAOR,EAAOM,GAAc,GAAGE,MAC/BC,IAAKT,EAAOI,GAAY,GAAGK,KAE7BN,EAAO,CACLI,KAAM,YACNC,MAAOR,EAAOM,GAAc,GAAGE,MAC/BC,IAAKT,EAAOI,GAAY,GAAGK,IAE3BC,YAAa,QAEfC,SAAOX,EAAQM,EAAcF,EAAaE,EAAe,EAAG,CAC1D,CAAC,QAASJ,EAASD,GACnB,CAAC,QAASE,EAAMF,GAChB,CAAC,OAAQE,EAAMF,GACf,CAAC,OAAQC,EAASD,MAItB,OAAOD"}