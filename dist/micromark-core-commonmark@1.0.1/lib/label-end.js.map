{"version":3,"file":"label-end.js","sources":["../../../node_modules/micromark-core-commonmark/lib/label-end.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Code} Code\n */\nimport {factoryDestination} from 'micromark-factory-destination'\nimport {factoryLabel} from 'micromark-factory-label'\nimport {factoryTitle} from 'micromark-factory-title'\nimport {factoryWhitespace} from 'micromark-factory-whitespace'\nimport {markdownLineEndingOrSpace} from 'micromark-util-character'\nimport {push, splice} from 'micromark-util-chunked'\nimport {normalizeIdentifier} from 'micromark-util-normalize-identifier'\nimport {resolveAll} from 'micromark-util-resolve-all'\n\n/** @type {Construct} */\nexport const labelEnd = {\n  name: 'labelEnd',\n  tokenize: tokenizeLabelEnd,\n  resolveTo: resolveToLabelEnd,\n  resolveAll: resolveAllLabelEnd\n}\n/** @type {Construct} */\n\nconst resourceConstruct = {\n  tokenize: tokenizeResource\n}\n/** @type {Construct} */\n\nconst fullReferenceConstruct = {\n  tokenize: tokenizeFullReference\n}\n/** @type {Construct} */\n\nconst collapsedReferenceConstruct = {\n  tokenize: tokenizeCollapsedReference\n}\n/** @type {Resolver} */\n\nfunction resolveAllLabelEnd(events) {\n  let index = -1\n  /** @type {Token} */\n\n  let token\n\n  while (++index < events.length) {\n    token = events[index][1]\n\n    if (\n      token.type === 'labelImage' ||\n      token.type === 'labelLink' ||\n      token.type === 'labelEnd'\n    ) {\n      // Remove the marker.\n      events.splice(index + 1, token.type === 'labelImage' ? 4 : 2)\n      token.type = 'data'\n      index++\n    }\n  }\n\n  return events\n}\n/** @type {Resolver} */\n\nfunction resolveToLabelEnd(events, context) {\n  let index = events.length\n  let offset = 0\n  /** @type {Token} */\n\n  let token\n  /** @type {number|undefined} */\n\n  let open\n  /** @type {number|undefined} */\n\n  let close\n  /** @type {Event[]} */\n\n  let media // Find an opening.\n\n  while (index--) {\n    token = events[index][1]\n\n    if (open) {\n      // If we see another link, or inactive link label, we’ve been here before.\n      if (\n        token.type === 'link' ||\n        (token.type === 'labelLink' && token._inactive)\n      ) {\n        break\n      } // Mark other link openings as inactive, as we can’t have links in\n      // links.\n\n      if (events[index][0] === 'enter' && token.type === 'labelLink') {\n        token._inactive = true\n      }\n    } else if (close) {\n      if (\n        events[index][0] === 'enter' &&\n        (token.type === 'labelImage' || token.type === 'labelLink') &&\n        !token._balanced\n      ) {\n        open = index\n\n        if (token.type !== 'labelLink') {\n          offset = 2\n          break\n        }\n      }\n    } else if (token.type === 'labelEnd') {\n      close = index\n    }\n  }\n\n  const group = {\n    type: events[open][1].type === 'labelLink' ? 'link' : 'image',\n    start: Object.assign({}, events[open][1].start),\n    end: Object.assign({}, events[events.length - 1][1].end)\n  }\n  const label = {\n    type: 'label',\n    start: Object.assign({}, events[open][1].start),\n    end: Object.assign({}, events[close][1].end)\n  }\n  const text = {\n    type: 'labelText',\n    start: Object.assign({}, events[open + offset + 2][1].end),\n    end: Object.assign({}, events[close - 2][1].start)\n  }\n  media = [\n    ['enter', group, context],\n    ['enter', label, context]\n  ] // Opening marker.\n\n  media = push(media, events.slice(open + 1, open + offset + 3)) // Text open.\n\n  media = push(media, [['enter', text, context]]) // Between.\n\n  media = push(\n    media,\n    resolveAll(\n      context.parser.constructs.insideSpan.null,\n      events.slice(open + offset + 4, close - 3),\n      context\n    )\n  ) // Text close, marker close, label close.\n\n  media = push(media, [\n    ['exit', text, context],\n    events[close - 2],\n    events[close - 1],\n    ['exit', label, context]\n  ]) // Reference, resource, or so.\n\n  media = push(media, events.slice(close + 1)) // Media close.\n\n  media = push(media, [['exit', group, context]])\n  splice(events, open, events.length, media)\n  return events\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeLabelEnd(effects, ok, nok) {\n  const self = this\n  let index = self.events.length\n  /** @type {Token} */\n\n  let labelStart\n  /** @type {boolean} */\n\n  let defined // Find an opening.\n\n  while (index--) {\n    if (\n      (self.events[index][1].type === 'labelImage' ||\n        self.events[index][1].type === 'labelLink') &&\n      !self.events[index][1]._balanced\n    ) {\n      labelStart = self.events[index][1]\n      break\n    }\n  }\n\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    if (!labelStart) {\n      return nok(code)\n    } // It’s a balanced bracket, but contains a link.\n\n    if (labelStart._inactive) return balanced(code)\n    defined = self.parser.defined.includes(\n      normalizeIdentifier(\n        self.sliceSerialize({\n          start: labelStart.end,\n          end: self.now()\n        })\n      )\n    )\n    effects.enter('labelEnd')\n    effects.enter('labelMarker')\n    effects.consume(code)\n    effects.exit('labelMarker')\n    effects.exit('labelEnd')\n    return afterLabelEnd\n  }\n  /** @type {State} */\n\n  function afterLabelEnd(code) {\n    // Resource: `[asd](fgh)`.\n    if (code === 40) {\n      return effects.attempt(\n        resourceConstruct,\n        ok,\n        defined ? ok : balanced\n      )(code)\n    } // Collapsed (`[asd][]`) or full (`[asd][fgh]`) reference?\n\n    if (code === 91) {\n      return effects.attempt(\n        fullReferenceConstruct,\n        ok,\n        defined\n          ? effects.attempt(collapsedReferenceConstruct, ok, balanced)\n          : balanced\n      )(code)\n    } // Shortcut reference: `[asd]`?\n\n    return defined ? ok(code) : balanced(code)\n  }\n  /** @type {State} */\n\n  function balanced(code) {\n    labelStart._balanced = true\n    return nok(code)\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeResource(effects, ok, nok) {\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('resource')\n    effects.enter('resourceMarker')\n    effects.consume(code)\n    effects.exit('resourceMarker')\n    return factoryWhitespace(effects, open)\n  }\n  /** @type {State} */\n\n  function open(code) {\n    if (code === 41) {\n      return end(code)\n    }\n\n    return factoryDestination(\n      effects,\n      destinationAfter,\n      nok,\n      'resourceDestination',\n      'resourceDestinationLiteral',\n      'resourceDestinationLiteralMarker',\n      'resourceDestinationRaw',\n      'resourceDestinationString',\n      3\n    )(code)\n  }\n  /** @type {State} */\n\n  function destinationAfter(code) {\n    return markdownLineEndingOrSpace(code)\n      ? factoryWhitespace(effects, between)(code)\n      : end(code)\n  }\n  /** @type {State} */\n\n  function between(code) {\n    if (code === 34 || code === 39 || code === 40) {\n      return factoryTitle(\n        effects,\n        factoryWhitespace(effects, end),\n        nok,\n        'resourceTitle',\n        'resourceTitleMarker',\n        'resourceTitleString'\n      )(code)\n    }\n\n    return end(code)\n  }\n  /** @type {State} */\n\n  function end(code) {\n    if (code === 41) {\n      effects.enter('resourceMarker')\n      effects.consume(code)\n      effects.exit('resourceMarker')\n      effects.exit('resource')\n      return ok\n    }\n\n    return nok(code)\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeFullReference(effects, ok, nok) {\n  const self = this\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    return factoryLabel.call(\n      self,\n      effects,\n      afterLabel,\n      nok,\n      'reference',\n      'referenceMarker',\n      'referenceString'\n    )(code)\n  }\n  /** @type {State} */\n\n  function afterLabel(code) {\n    return self.parser.defined.includes(\n      normalizeIdentifier(\n        self.sliceSerialize(self.events[self.events.length - 1][1]).slice(1, -1)\n      )\n    )\n      ? ok(code)\n      : nok(code)\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeCollapsedReference(effects, ok, nok) {\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('reference')\n    effects.enter('referenceMarker')\n    effects.consume(code)\n    effects.exit('referenceMarker')\n    return open\n  }\n  /** @type {State} */\n\n  function open(code) {\n    if (code === 93) {\n      effects.enter('referenceMarker')\n      effects.consume(code)\n      effects.exit('referenceMarker')\n      effects.exit('reference')\n      return ok\n    }\n\n    return nok(code)\n  }\n}\n"],"names":["labelEnd","name","tokenize","effects","ok","nok","self","this","labelStart","defined","index","events","length","type","_balanced","code","_inactive","balanced","parser","includes","normalizeIdentifier","sliceSerialize","start","end","now","enter","consume","exit","afterLabelEnd","attempt","resourceConstruct","fullReferenceConstruct","collapsedReferenceConstruct","resolveTo","context","token","open","close","media","offset","group","Object","assign","label","text","push","slice","resolveAll","constructs","insideSpan","null","splice","factoryWhitespace","factoryDestination","destinationAfter","markdownLineEndingOrSpace","between","factoryTitle","factoryLabel","call","afterLabel"],"mappings":"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"}