{"version":3,"file":"definition.js","sources":["../../../node_modules/micromark-core-commonmark/lib/definition.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n */\nimport {factoryDestination} from 'micromark-factory-destination'\nimport {factoryLabel} from 'micromark-factory-label'\nimport {factorySpace} from 'micromark-factory-space'\nimport {factoryTitle} from 'micromark-factory-title'\nimport {factoryWhitespace} from 'micromark-factory-whitespace'\nimport {normalizeIdentifier} from 'micromark-util-normalize-identifier'\nimport {\n  markdownLineEnding,\n  markdownLineEndingOrSpace\n} from 'micromark-util-character'\n\n/** @type {Construct} */\nexport const definition = {\n  name: 'definition',\n  tokenize: tokenizeDefinition\n}\n/** @type {Construct} */\n\nconst titleConstruct = {\n  tokenize: tokenizeTitle,\n  partial: true\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeDefinition(effects, ok, nok) {\n  const self = this\n  /** @type {string} */\n\n  let identifier\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('definition')\n    return factoryLabel.call(\n      self,\n      effects,\n      labelAfter,\n      nok,\n      'definitionLabel',\n      'definitionLabelMarker',\n      'definitionLabelString'\n    )(code)\n  }\n  /** @type {State} */\n\n  function labelAfter(code) {\n    identifier = normalizeIdentifier(\n      self.sliceSerialize(self.events[self.events.length - 1][1]).slice(1, -1)\n    )\n\n    if (code === 58) {\n      effects.enter('definitionMarker')\n      effects.consume(code)\n      effects.exit('definitionMarker') // Note: blank lines canâ€™t exist in content.\n\n      return factoryWhitespace(\n        effects,\n        factoryDestination(\n          effects,\n          effects.attempt(\n            titleConstruct,\n            factorySpace(effects, after, 'whitespace'),\n            factorySpace(effects, after, 'whitespace')\n          ),\n          nok,\n          'definitionDestination',\n          'definitionDestinationLiteral',\n          'definitionDestinationLiteralMarker',\n          'definitionDestinationRaw',\n          'definitionDestinationString'\n        )\n      )\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function after(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('definition')\n\n      if (!self.parser.defined.includes(identifier)) {\n        self.parser.defined.push(identifier)\n      }\n\n      return ok(code)\n    }\n\n    return nok(code)\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeTitle(effects, ok, nok) {\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    return markdownLineEndingOrSpace(code)\n      ? factoryWhitespace(effects, before)(code)\n      : nok(code)\n  }\n  /** @type {State} */\n\n  function before(code) {\n    if (code === 34 || code === 39 || code === 40) {\n      return factoryTitle(\n        effects,\n        factorySpace(effects, after, 'whitespace'),\n        nok,\n        'definitionTitle',\n        'definitionTitleMarker',\n        'definitionTitleString'\n      )(code)\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function after(code) {\n    return code === null || markdownLineEnding(code) ? ok(code) : nok(code)\n  }\n}\n"],"names":["definition","name","tokenize","effects","ok","nok","self","this","identifier","code","enter","factoryLabel","call","labelAfter","normalizeIdentifier","sliceSerialize","events","length","slice","consume","exit","factoryWhitespace","factoryDestination","attempt","titleConstruct","factorySpace","after","markdownLineEnding","parser","defined","includes","push","markdownLineEndingOrSpace","before","factoryTitle","partial"],"mappings":"kQAiBaA,EAAa,CACxBC,KAAM,aACNC,SAUF,SAA4BC,EAASC,EAAIC,GACvC,MAAMC,EAAOC,KAGb,IAAIC,EACJ,OAGA,SAAeC,GAEb,OADAN,EAAQO,MAAM,cACPC,eAAaC,KAClBN,EACAH,EACAU,EACAR,EACA,kBACA,wBACA,wBAPKM,CAQLF,IAIJ,SAASI,EAAWJ,GAKlB,OAJAD,EAAaM,sBACXR,EAAKS,eAAeT,EAAKU,OAAOV,EAAKU,OAAOC,OAAS,GAAG,IAAIC,MAAM,GAAI,IAG3D,KAATT,GACFN,EAAQO,MAAM,oBACdP,EAAQgB,QAAQV,GAChBN,EAAQiB,KAAK,oBAENC,oBACLlB,EACAmB,qBACEnB,EACAA,EAAQoB,QACNC,EACAC,eAAatB,EAASuB,EAAO,cAC7BD,eAAatB,EAASuB,EAAO,eAE/BrB,EACA,wBACA,+BACA,qCACA,2BACA,iCAKCA,EAAII,GAIb,SAASiB,EAAMjB,GACb,OAAa,OAATA,GAAiBkB,qBAAmBlB,IACtCN,EAAQiB,KAAK,cAERd,EAAKsB,OAAOC,QAAQC,SAAStB,IAChCF,EAAKsB,OAAOC,QAAQE,KAAKvB,GAGpBJ,EAAGK,IAGLJ,EAAII,MAxETe,EAAiB,CACrBtB,SA4EF,SAAuBC,EAASC,EAAIC,GAClC,OAGA,SAAeI,GACb,OAAOuB,4BAA0BvB,GAC7BY,oBAAkBlB,EAAS8B,EAA3BZ,CAAmCZ,GACnCJ,EAAII,IAIV,SAASwB,EAAOxB,GACd,OAAa,KAATA,GAAwB,KAATA,GAAwB,KAATA,EACzByB,eACL/B,EACAsB,eAAatB,EAASuB,EAAO,cAC7BrB,EACA,kBACA,wBACA,wBANK6B,CAOLzB,GAGGJ,EAAII,GAIb,SAASiB,EAAMjB,GACb,OAAgB,OAATA,GAAiBkB,qBAAmBlB,GAAQL,EAAGK,GAAQJ,EAAII,KAvGpE0B,SAAS"}