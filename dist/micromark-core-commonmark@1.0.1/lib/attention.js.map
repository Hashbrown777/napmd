{"version":3,"file":"attention.js","sources":["../../../node_modules/micromark-core-commonmark/lib/attention.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').Code} Code\n * @typedef {import('micromark-util-types').Point} Point\n */\nimport {push, splice} from 'micromark-util-chunked'\nimport {classifyCharacter} from 'micromark-util-classify-character'\nimport {resolveAll} from 'micromark-util-resolve-all'\n\n/** @type {Construct} */\nexport const attention = {\n  name: 'attention',\n  tokenize: tokenizeAttention,\n  resolveAll: resolveAllAttention\n}\n/**\n * Take all events and resolve attention to emphasis or strong.\n *\n * @type {Resolver}\n */\n\nfunction resolveAllAttention(events, context) {\n  let index = -1\n  /** @type {number} */\n\n  let open\n  /** @type {Token} */\n\n  let group\n  /** @type {Token} */\n\n  let text\n  /** @type {Token} */\n\n  let openingSequence\n  /** @type {Token} */\n\n  let closingSequence\n  /** @type {number} */\n\n  let use\n  /** @type {Event[]} */\n\n  let nextEvents\n  /** @type {number} */\n\n  let offset // Walk through all events.\n  //\n  // Note: performance of this is fine on an mb of normal markdown, but it’s\n  // a bottleneck for malicious stuff.\n\n  while (++index < events.length) {\n    // Find a token that can close.\n    if (\n      events[index][0] === 'enter' &&\n      events[index][1].type === 'attentionSequence' &&\n      events[index][1]._close\n    ) {\n      open = index // Now walk back to find an opener.\n\n      while (open--) {\n        // Find a token that can open the closer.\n        if (\n          events[open][0] === 'exit' &&\n          events[open][1].type === 'attentionSequence' &&\n          events[open][1]._open && // If the markers are the same:\n          context.sliceSerialize(events[open][1]).charCodeAt(0) ===\n            context.sliceSerialize(events[index][1]).charCodeAt(0)\n        ) {\n          // If the opening can close or the closing can open,\n          // and the close size *is not* a multiple of three,\n          // but the sum of the opening and closing size *is* multiple of three,\n          // then don’t match.\n          if (\n            (events[open][1]._close || events[index][1]._open) &&\n            (events[index][1].end.offset - events[index][1].start.offset) % 3 &&\n            !(\n              (events[open][1].end.offset -\n                events[open][1].start.offset +\n                events[index][1].end.offset -\n                events[index][1].start.offset) %\n              3\n            )\n          ) {\n            continue\n          } // Number of markers to use from the sequence.\n\n          use =\n            events[open][1].end.offset - events[open][1].start.offset > 1 &&\n            events[index][1].end.offset - events[index][1].start.offset > 1\n              ? 2\n              : 1\n          const start = Object.assign({}, events[open][1].end)\n          const end = Object.assign({}, events[index][1].start)\n          movePoint(start, -use)\n          movePoint(end, use)\n          openingSequence = {\n            type: use > 1 ? 'strongSequence' : 'emphasisSequence',\n            start,\n            end: Object.assign({}, events[open][1].end)\n          }\n          closingSequence = {\n            type: use > 1 ? 'strongSequence' : 'emphasisSequence',\n            start: Object.assign({}, events[index][1].start),\n            end\n          }\n          text = {\n            type: use > 1 ? 'strongText' : 'emphasisText',\n            start: Object.assign({}, events[open][1].end),\n            end: Object.assign({}, events[index][1].start)\n          }\n          group = {\n            type: use > 1 ? 'strong' : 'emphasis',\n            start: Object.assign({}, openingSequence.start),\n            end: Object.assign({}, closingSequence.end)\n          }\n          events[open][1].end = Object.assign({}, openingSequence.start)\n          events[index][1].start = Object.assign({}, closingSequence.end)\n          nextEvents = [] // If there are more markers in the opening, add them before.\n\n          if (events[open][1].end.offset - events[open][1].start.offset) {\n            nextEvents = push(nextEvents, [\n              ['enter', events[open][1], context],\n              ['exit', events[open][1], context]\n            ])\n          } // Opening.\n\n          nextEvents = push(nextEvents, [\n            ['enter', group, context],\n            ['enter', openingSequence, context],\n            ['exit', openingSequence, context],\n            ['enter', text, context]\n          ]) // Between.\n\n          nextEvents = push(\n            nextEvents,\n            resolveAll(\n              context.parser.constructs.insideSpan.null,\n              events.slice(open + 1, index),\n              context\n            )\n          ) // Closing.\n\n          nextEvents = push(nextEvents, [\n            ['exit', text, context],\n            ['enter', closingSequence, context],\n            ['exit', closingSequence, context],\n            ['exit', group, context]\n          ]) // If there are more markers in the closing, add them after.\n\n          if (events[index][1].end.offset - events[index][1].start.offset) {\n            offset = 2\n            nextEvents = push(nextEvents, [\n              ['enter', events[index][1], context],\n              ['exit', events[index][1], context]\n            ])\n          } else {\n            offset = 0\n          }\n\n          splice(events, open - 1, index - open + 3, nextEvents)\n          index = open + nextEvents.length - offset - 2\n          break\n        }\n      }\n    }\n  } // Remove remaining sequences.\n\n  index = -1\n\n  while (++index < events.length) {\n    if (events[index][1].type === 'attentionSequence') {\n      events[index][1].type = 'data'\n    }\n  }\n\n  return events\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeAttention(effects, ok) {\n  const attentionMarkers = this.parser.constructs.attentionMarkers.null\n  const previous = this.previous\n  const before = classifyCharacter(previous)\n  /** @type {NonNullable<Code>} */\n\n  let marker\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('attentionSequence')\n    marker = code\n    return sequence(code)\n  }\n  /** @type {State} */\n\n  function sequence(code) {\n    if (code === marker) {\n      effects.consume(code)\n      return sequence\n    }\n\n    const token = effects.exit('attentionSequence')\n    const after = classifyCharacter(code)\n    const open =\n      !after || (after === 2 && before) || attentionMarkers.includes(code)\n    const close =\n      !before || (before === 2 && after) || attentionMarkers.includes(previous)\n    token._open = Boolean(marker === 42 ? open : open && (before || !close))\n    token._close = Boolean(marker === 42 ? close : close && (after || !open))\n    return ok(code)\n  }\n}\n/**\n * Move a point a bit.\n *\n * Note: `move` only works inside lines! It’s not possible to move past other\n * chunks (replacement characters, tabs, or line endings).\n *\n * @param {Point} point\n * @param {number} offset\n * @returns {void}\n */\n\nfunction movePoint(point, offset) {\n  point.column += offset\n  point.offset += offset\n  point._bufferIndex += offset\n}\n"],"names":["attention","name","tokenize","effects","ok","attentionMarkers","this","parser","constructs","null","previous","before","classifyCharacter","marker","code","enter","sequence","consume","token","exit","after","open","includes","close","_open","Boolean","_close","resolveAll","events","context","group","text","openingSequence","closingSequence","use","nextEvents","offset","index","length","type","sliceSerialize","charCodeAt","end","start","Object","assign","movePoint","push","insideSpan","slice","splice","point","column","_bufferIndex"],"mappings":"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"}