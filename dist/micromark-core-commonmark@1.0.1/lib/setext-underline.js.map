{"version":3,"file":"setext-underline.js","sources":["../../../node_modules/micromark-core-commonmark/lib/setext-underline.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Code} Code\n */\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEnding} from 'micromark-util-character'\n\n/** @type {Construct} */\nexport const setextUnderline = {\n  name: 'setextUnderline',\n  tokenize: tokenizeSetextUnderline,\n  resolveTo: resolveToSetextUnderline\n}\n/** @type {Resolver} */\n\nfunction resolveToSetextUnderline(events, context) {\n  let index = events.length\n  /** @type {number|undefined} */\n\n  let content\n  /** @type {number|undefined} */\n\n  let text\n  /** @type {number|undefined} */\n\n  let definition // Find the opening of the content.\n  // It’ll always exist: we don’t tokenize if it isn’t there.\n\n  while (index--) {\n    if (events[index][0] === 'enter') {\n      if (events[index][1].type === 'content') {\n        content = index\n        break\n      }\n\n      if (events[index][1].type === 'paragraph') {\n        text = index\n      }\n    } // Exit\n    else {\n      if (events[index][1].type === 'content') {\n        // Remove the content end (if needed we’ll add it later)\n        events.splice(index, 1)\n      }\n\n      if (!definition && events[index][1].type === 'definition') {\n        definition = index\n      }\n    }\n  }\n\n  const heading = {\n    type: 'setextHeading',\n    start: Object.assign({}, events[text][1].start),\n    end: Object.assign({}, events[events.length - 1][1].end)\n  } // Change the paragraph to setext heading text.\n\n  events[text][1].type = 'setextHeadingText' // If we have definitions in the content, we’ll keep on having content,\n  // but we need move it.\n\n  if (definition) {\n    events.splice(text, 0, ['enter', heading, context])\n    events.splice(definition + 1, 0, ['exit', events[content][1], context])\n    events[content][1].end = Object.assign({}, events[definition][1].end)\n  } else {\n    events[content][1] = heading\n  } // Add the heading exit at the end.\n\n  events.push(['exit', heading, context])\n  return events\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeSetextUnderline(effects, ok, nok) {\n  const self = this\n  let index = self.events.length\n  /** @type {NonNullable<Code>} */\n\n  let marker\n  /** @type {boolean} */\n\n  let paragraph // Find an opening.\n\n  while (index--) {\n    // Skip enter/exit of line ending, line prefix, and content.\n    // We can now either have a definition or a paragraph.\n    if (\n      self.events[index][1].type !== 'lineEnding' &&\n      self.events[index][1].type !== 'linePrefix' &&\n      self.events[index][1].type !== 'content'\n    ) {\n      paragraph = self.events[index][1].type === 'paragraph'\n      break\n    }\n  }\n\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    if (!self.parser.lazy[self.now().line] && (self.interrupt || paragraph)) {\n      effects.enter('setextHeadingLine')\n      effects.enter('setextHeadingLineSequence')\n      marker = code\n      return closingSequence(code)\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function closingSequence(code) {\n    if (code === marker) {\n      effects.consume(code)\n      return closingSequence\n    }\n\n    effects.exit('setextHeadingLineSequence')\n    return factorySpace(effects, closingSequenceEnd, 'lineSuffix')(code)\n  }\n  /** @type {State} */\n\n  function closingSequenceEnd(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('setextHeadingLine')\n      return ok(code)\n    }\n\n    return nok(code)\n  }\n}\n"],"names":["setextUnderline","name","tokenize","effects","ok","nok","self","this","marker","paragraph","index","events","length","type","code","parser","lazy","now","line","interrupt","enter","closingSequence","consume","exit","factorySpace","closingSequenceEnd","markdownLineEnding","resolveTo","context","content","text","definition","splice","heading","start","Object","assign","end","push"],"mappings":"+FAWaA,EAAkB,CAC7BC,KAAM,kBACNC,SA+DF,SAAiCC,EAASC,EAAIC,GAC5C,MAAMC,EAAOC,KACb,IAGIC,EAGAC,EANAC,EAAQJ,EAAKK,OAAOC,OAQxB,KAAOF,KAGL,GACiC,eAA/BJ,EAAKK,OAAOD,GAAO,GAAGG,MACS,eAA/BP,EAAKK,OAAOD,GAAO,GAAGG,MACS,YAA/BP,EAAKK,OAAOD,GAAO,GAAGG,KACtB,CACAJ,EAA2C,cAA/BH,EAAKK,OAAOD,GAAO,GAAGG,KAClC,MAIJ,OAGA,SAAeC,GACb,IAAKR,EAAKS,OAAOC,KAAKV,EAAKW,MAAMC,QAAUZ,EAAKa,WAAaV,GAI3D,OAHAN,EAAQiB,MAAM,qBACdjB,EAAQiB,MAAM,6BACdZ,EAASM,EACFO,EAAgBP,GAGzB,OAAOT,EAAIS,IAIb,SAASO,EAAgBP,GACvB,OAAIA,IAASN,GACXL,EAAQmB,QAAQR,GACTO,IAGTlB,EAAQoB,KAAK,6BACNC,eAAarB,EAASsB,EAAoB,aAA1CD,CAAwDV,IAIjE,SAASW,EAAmBX,GAC1B,OAAa,OAATA,GAAiBY,qBAAmBZ,IACtCX,EAAQoB,KAAK,qBACNnB,EAAGU,IAGLT,EAAIS,KArHba,UAIF,SAAkChB,EAAQiB,GACxC,IAGIC,EAGAC,EAGAC,EATArB,EAAQC,EAAOC,OAYnB,KAAOF,KACL,GAAyB,UAArBC,EAAOD,GAAO,GAAgB,CAChC,GAA8B,YAA1BC,EAAOD,GAAO,GAAGG,KAAoB,CACvCgB,EAAUnB,EACV,MAG4B,cAA1BC,EAAOD,GAAO,GAAGG,OACnBiB,EAAOpB,OAIqB,YAA1BC,EAAOD,GAAO,GAAGG,MAEnBF,EAAOqB,OAAOtB,EAAO,GAGlBqB,GAAwC,eAA1BpB,EAAOD,GAAO,GAAGG,OAClCkB,EAAarB,GAKnB,MAAMuB,EAAU,CACdpB,KAAM,gBACNqB,MAAOC,OAAOC,OAAO,GAAIzB,EAAOmB,GAAM,GAAGI,OACzCG,IAAKF,OAAOC,OAAO,GAAIzB,EAAOA,EAAOC,OAAS,GAAG,GAAGyB,MAGtD1B,EAAOmB,GAAM,GAAGjB,KAAO,oBAGnBkB,GACFpB,EAAOqB,OAAOF,EAAM,EAAG,CAAC,QAASG,EAASL,IAC1CjB,EAAOqB,OAAOD,EAAa,EAAG,EAAG,CAAC,OAAQpB,EAAOkB,GAAS,GAAID,IAC9DjB,EAAOkB,GAAS,GAAGQ,IAAMF,OAAOC,OAAO,GAAIzB,EAAOoB,GAAY,GAAGM,MAEjE1B,EAAOkB,GAAS,GAAKI,EAIvB,OADAtB,EAAO2B,KAAK,CAAC,OAAQL,EAASL,IACvBjB"}