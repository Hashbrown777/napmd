{"version":3,"file":"code-text.js","sources":["../../../node_modules/micromark-core-commonmark/lib/code-text.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Previous} Previous\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').State} State\n */\nimport {markdownLineEnding} from 'micromark-util-character'\n\n/** @type {Construct} */\nexport const codeText = {\n  name: 'codeText',\n  tokenize: tokenizeCodeText,\n  resolve: resolveCodeText,\n  previous\n}\n/** @type {Resolver} */\n\nfunction resolveCodeText(events) {\n  let tailExitIndex = events.length - 4\n  let headEnterIndex = 3\n  /** @type {number} */\n\n  let index\n  /** @type {number|undefined} */\n\n  let enter // If we start and end with an EOL or a space.\n\n  if (\n    (events[headEnterIndex][1].type === 'lineEnding' ||\n      events[headEnterIndex][1].type === 'space') &&\n    (events[tailExitIndex][1].type === 'lineEnding' ||\n      events[tailExitIndex][1].type === 'space')\n  ) {\n    index = headEnterIndex // And we have data.\n\n    while (++index < tailExitIndex) {\n      if (events[index][1].type === 'codeTextData') {\n        // Then we have padding.\n        events[headEnterIndex][1].type = 'codeTextPadding'\n        events[tailExitIndex][1].type = 'codeTextPadding'\n        headEnterIndex += 2\n        tailExitIndex -= 2\n        break\n      }\n    }\n  } // Merge adjacent spaces and data.\n\n  index = headEnterIndex - 1\n  tailExitIndex++\n\n  while (++index <= tailExitIndex) {\n    if (enter === undefined) {\n      if (index !== tailExitIndex && events[index][1].type !== 'lineEnding') {\n        enter = index\n      }\n    } else if (\n      index === tailExitIndex ||\n      events[index][1].type === 'lineEnding'\n    ) {\n      events[enter][1].type = 'codeTextData'\n\n      if (index !== enter + 2) {\n        events[enter][1].end = events[index - 1][1].end\n        events.splice(enter + 2, index - enter - 2)\n        tailExitIndex -= index - enter - 2\n        index = enter + 2\n      }\n\n      enter = undefined\n    }\n  }\n\n  return events\n}\n/** @type {Previous} */\n\nfunction previous(code) {\n  // If there is a previous code, there will always be a tail.\n  return (\n    code !== 96 ||\n    this.events[this.events.length - 1][1].type === 'characterEscape'\n  )\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeCodeText(effects, ok, nok) {\n  const self = this\n  let sizeOpen = 0\n  /** @type {number} */\n\n  let size\n  /** @type {Token} */\n\n  let token\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('codeText')\n    effects.enter('codeTextSequence')\n    return openingSequence(code)\n  }\n  /** @type {State} */\n\n  function openingSequence(code) {\n    if (code === 96) {\n      effects.consume(code)\n      sizeOpen++\n      return openingSequence\n    }\n\n    effects.exit('codeTextSequence')\n    return gap(code)\n  }\n  /** @type {State} */\n\n  function gap(code) {\n    // EOF.\n    if (code === null) {\n      return nok(code)\n    } // Closing fence?\n    // Could also be data.\n\n    if (code === 96) {\n      token = effects.enter('codeTextSequence')\n      size = 0\n      return closingSequence(code)\n    } // Tabs don’t work, and virtual spaces don’t make sense.\n\n    if (code === 32) {\n      effects.enter('space')\n      effects.consume(code)\n      effects.exit('space')\n      return gap\n    }\n\n    if (markdownLineEnding(code)) {\n      effects.enter('lineEnding')\n      effects.consume(code)\n      effects.exit('lineEnding')\n      return gap\n    } // Data.\n\n    effects.enter('codeTextData')\n    return data(code)\n  } // In code.\n\n  /** @type {State} */\n\n  function data(code) {\n    if (\n      code === null ||\n      code === 32 ||\n      code === 96 ||\n      markdownLineEnding(code)\n    ) {\n      effects.exit('codeTextData')\n      return gap(code)\n    }\n\n    effects.consume(code)\n    return data\n  } // Closing fence.\n\n  /** @type {State} */\n\n  function closingSequence(code) {\n    // More.\n    if (code === 96) {\n      effects.consume(code)\n      size++\n      return closingSequence\n    } // Done!\n\n    if (size === sizeOpen) {\n      effects.exit('codeTextSequence')\n      effects.exit('codeText')\n      return ok(code)\n    } // More or less accents: mark as data.\n\n    token.type = 'codeTextData'\n    return data(code)\n  }\n}\n"],"names":["codeText","name","tokenize","effects","ok","nok","size","token","sizeOpen","code","enter","openingSequence","consume","exit","gap","closingSequence","markdownLineEnding","data","type","resolve","events","index","tailExitIndex","length","headEnterIndex","undefined","end","splice","previous","this"],"mappings":"mEAWaA,EAAW,CACtBC,KAAM,WACNC,SA0EF,SAA0BC,EAASC,EAAIC,GAErC,IAGIC,EAGAC,EANAC,EAAW,EAOf,OAGA,SAAeC,GAGb,OAFAN,EAAQO,MAAM,YACdP,EAAQO,MAAM,oBACPC,EAAgBF,IAIzB,SAASE,EAAgBF,GACvB,OAAa,KAATA,GACFN,EAAQS,QAAQH,GAChBD,IACOG,IAGTR,EAAQU,KAAK,oBACNC,EAAIL,IAIb,SAASK,EAAIL,GAEX,OAAa,OAATA,EACKJ,EAAII,GAIA,KAATA,GACFF,EAAQJ,EAAQO,MAAM,oBACtBJ,EAAO,EACAS,EAAgBN,IAGZ,KAATA,GACFN,EAAQO,MAAM,SACdP,EAAQS,QAAQH,GAChBN,EAAQU,KAAK,SACNC,GAGLE,qBAAmBP,IACrBN,EAAQO,MAAM,cACdP,EAAQS,QAAQH,GAChBN,EAAQU,KAAK,cACNC,IAGTX,EAAQO,MAAM,gBACPO,EAAKR,IAKd,SAASQ,EAAKR,GACZ,OACW,OAATA,GACS,KAATA,GACS,KAATA,GACAO,qBAAmBP,IAEnBN,EAAQU,KAAK,gBACNC,EAAIL,KAGbN,EAAQS,QAAQH,GACTQ,GAKT,SAASF,EAAgBN,GAEvB,OAAa,KAATA,GACFN,EAAQS,QAAQH,GAChBH,IACOS,GAGLT,IAASE,GACXL,EAAQU,KAAK,oBACbV,EAAQU,KAAK,YACNT,EAAGK,KAGZF,EAAMW,KAAO,eACND,EAAKR,MAzKdU,QAKF,SAAyBC,GACvB,IAIIC,EAGAX,EAPAY,EAAgBF,EAAOG,OAAS,EAChCC,EAAiB,EAQrB,KACsC,eAAnCJ,EAAOI,GAAgB,GAAGN,MACU,UAAnCE,EAAOI,GAAgB,GAAGN,MACO,eAAlCE,EAAOE,GAAe,GAAGJ,MACU,UAAlCE,EAAOE,GAAe,GAAGJ,MAI3B,IAFAG,EAAQG,IAECH,EAAQC,GACf,GAA8B,iBAA1BF,EAAOC,GAAO,GAAGH,KAAyB,CAE5CE,EAAOI,GAAgB,GAAGN,KAAO,kBACjCE,EAAOE,GAAe,GAAGJ,KAAO,kBAChCM,GAAkB,EAClBF,GAAiB,EACjB,MAKND,EAAQG,EAAiB,EACzBF,IAEA,OAASD,GAASC,QACFG,IAAVf,EACEW,IAAUC,GAA2C,eAA1BF,EAAOC,GAAO,GAAGH,OAC9CR,EAAQW,GAGVA,IAAUC,GACgB,eAA1BF,EAAOC,GAAO,GAAGH,OAEjBE,EAAOV,GAAO,GAAGQ,KAAO,eAEpBG,IAAUX,EAAQ,IACpBU,EAAOV,GAAO,GAAGgB,IAAMN,EAAOC,EAAQ,GAAG,GAAGK,IAC5CN,EAAOO,OAAOjB,EAAQ,EAAGW,EAAQX,EAAQ,GACzCY,GAAiBD,EAAQX,EAAQ,EACjCW,EAAQX,EAAQ,GAGlBA,OAAQe,GAIZ,OAAOL,GA3DPQ,SA+DF,SAAkBnB,GAEhB,OACW,KAATA,GACgD,oBAAhDoB,KAAKT,OAAOS,KAAKT,OAAOG,OAAS,GAAG,GAAGL"}