{"version":3,"file":"markdown-table@3.0.1.js","sources":["../node_modules/markdown-table/index.js"],"sourcesContent":["/**\n * @typedef MarkdownTableOptions\n * @property {string|null|Array.<string|null|undefined>} [align]\n * @property {boolean} [padding=true]\n * @property {boolean} [delimiterStart=true]\n * @property {boolean} [delimiterStart=true]\n * @property {boolean} [delimiterEnd=true]\n * @property {boolean} [alignDelimiters=true]\n * @property {(value: string) => number} [stringLength]\n */\n\n/**\n * Create a table from a matrix of strings.\n *\n * @param {Array.<Array.<string|null|undefined>>} table\n * @param {MarkdownTableOptions} [options]\n * @returns {string}\n */\nexport function markdownTable(table, options) {\n  const settings = options || {}\n  const align = (settings.align || []).concat()\n  const stringLength = settings.stringLength || defaultStringLength\n  /** @type {number[]} Character codes as symbols for alignment per column. */\n  const alignments = []\n  let rowIndex = -1\n  /** @type {string[][]} Cells per row. */\n  const cellMatrix = []\n  /** @type {number[][]} Sizes of each cell per row. */\n  const sizeMatrix = []\n  /** @type {number[]} */\n  const longestCellByColumn = []\n  let mostCellsPerRow = 0\n  /** @type {number} */\n  let columnIndex\n  /** @type {string[]} Cells of current row */\n  let row\n  /** @type {number[]} Sizes of current row */\n  let sizes\n  /** @type {number} Sizes of current cell */\n  let size\n  /** @type {string} Current cell */\n  let cell\n  /** @type {string[]} Chunks of current line. */\n  let line\n  /** @type {string} */\n  let before\n  /** @type {string} */\n  let after\n  /** @type {number} */\n  let code\n\n  // This is a superfluous loop if we don’t align delimiters, but otherwise we’d\n  // do superfluous work when aligning, so optimize for aligning.\n  while (++rowIndex < table.length) {\n    columnIndex = -1\n    row = []\n    sizes = []\n\n    if (table[rowIndex].length > mostCellsPerRow) {\n      mostCellsPerRow = table[rowIndex].length\n    }\n\n    while (++columnIndex < table[rowIndex].length) {\n      cell = serialize(table[rowIndex][columnIndex])\n\n      if (settings.alignDelimiters !== false) {\n        size = stringLength(cell)\n        sizes[columnIndex] = size\n\n        if (\n          longestCellByColumn[columnIndex] === undefined ||\n          size > longestCellByColumn[columnIndex]\n        ) {\n          longestCellByColumn[columnIndex] = size\n        }\n      }\n\n      row.push(cell)\n    }\n\n    cellMatrix[rowIndex] = row\n    sizeMatrix[rowIndex] = sizes\n  }\n\n  // Figure out which alignments to use.\n  columnIndex = -1\n\n  if (typeof align === 'object' && 'length' in align) {\n    while (++columnIndex < mostCellsPerRow) {\n      alignments[columnIndex] = toAlignment(align[columnIndex])\n    }\n  } else {\n    code = toAlignment(align)\n\n    while (++columnIndex < mostCellsPerRow) {\n      alignments[columnIndex] = code\n    }\n  }\n\n  // Inject the alignment row.\n  columnIndex = -1\n  row = []\n  sizes = []\n\n  while (++columnIndex < mostCellsPerRow) {\n    code = alignments[columnIndex]\n    before = ''\n    after = ''\n\n    if (code === 99 /* `c` */) {\n      before = ':'\n      after = ':'\n    } else if (code === 108 /* `l` */) {\n      before = ':'\n    } else if (code === 114 /* `r` */) {\n      after = ':'\n    }\n\n    // There *must* be at least one hyphen-minus in each alignment cell.\n    size =\n      settings.alignDelimiters === false\n        ? 1\n        : Math.max(\n            1,\n            longestCellByColumn[columnIndex] - before.length - after.length\n          )\n\n    cell = before + '-'.repeat(size) + after\n\n    if (settings.alignDelimiters !== false) {\n      size = before.length + size + after.length\n\n      if (size > longestCellByColumn[columnIndex]) {\n        longestCellByColumn[columnIndex] = size\n      }\n\n      sizes[columnIndex] = size\n    }\n\n    row[columnIndex] = cell\n  }\n\n  // Inject the alignment row.\n  cellMatrix.splice(1, 0, row)\n  sizeMatrix.splice(1, 0, sizes)\n\n  rowIndex = -1\n  /** @type {string[]} */\n  const lines = []\n\n  while (++rowIndex < cellMatrix.length) {\n    row = cellMatrix[rowIndex]\n    sizes = sizeMatrix[rowIndex]\n    columnIndex = -1\n    line = []\n\n    while (++columnIndex < mostCellsPerRow) {\n      cell = row[columnIndex] || ''\n      before = ''\n      after = ''\n\n      if (settings.alignDelimiters !== false) {\n        size = longestCellByColumn[columnIndex] - (sizes[columnIndex] || 0)\n        code = alignments[columnIndex]\n\n        if (code === 114 /* `r` */) {\n          before = ' '.repeat(size)\n        } else if (code === 99 /* `c` */) {\n          if (size % 2) {\n            before = ' '.repeat(size / 2 + 0.5)\n            after = ' '.repeat(size / 2 - 0.5)\n          } else {\n            before = ' '.repeat(size / 2)\n            after = before\n          }\n        } else {\n          after = ' '.repeat(size)\n        }\n      }\n\n      if (settings.delimiterStart !== false && !columnIndex) {\n        line.push('|')\n      }\n\n      if (\n        settings.padding !== false &&\n        // Don’t add the opening space if we’re not aligning and the cell is\n        // empty: there will be a closing space.\n        !(settings.alignDelimiters === false && cell === '') &&\n        (settings.delimiterStart !== false || columnIndex)\n      ) {\n        line.push(' ')\n      }\n\n      if (settings.alignDelimiters !== false) {\n        line.push(before)\n      }\n\n      line.push(cell)\n\n      if (settings.alignDelimiters !== false) {\n        line.push(after)\n      }\n\n      if (settings.padding !== false) {\n        line.push(' ')\n      }\n\n      if (\n        settings.delimiterEnd !== false ||\n        columnIndex !== mostCellsPerRow - 1\n      ) {\n        line.push('|')\n      }\n    }\n\n    lines.push(\n      settings.delimiterEnd === false\n        ? line.join('').replace(/ +$/, '')\n        : line.join('')\n    )\n  }\n\n  return lines.join('\\n')\n}\n\n/**\n * @param {string|null|undefined} [value]\n * @returns {string}\n */\nfunction serialize(value) {\n  return value === null || value === undefined ? '' : String(value)\n}\n\n/**\n * @param {string} value\n * @returns {number}\n */\nfunction defaultStringLength(value) {\n  return value.length\n}\n\n/**\n * @param {string|null|undefined} value\n * @returns {number}\n */\nfunction toAlignment(value) {\n  const code = typeof value === 'string' ? value.charCodeAt(0) : 0\n\n  return code === 67 /* `C` */ || code === 99 /* `c` */\n    ? 99 /* `c` */\n    : code === 76 /* `L` */ || code === 108 /* `l` */\n    ? 108 /* `l` */\n    : code === 82 /* `R` */ || code === 114 /* `r` */\n    ? 114 /* `r` */\n    : 0\n}\n"],"names":["defaultStringLength","value","length","toAlignment","code","charCodeAt","table","options","settings","align","concat","stringLength","alignments","rowIndex","cellMatrix","sizeMatrix","longestCellByColumn","columnIndex","row","sizes","size","cell","line","before","after","mostCellsPerRow","String","alignDelimiters","undefined","push","Math","max","repeat","splice","lines","delimiterStart","padding","delimiterEnd","join","replace"],"mappings":"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"}