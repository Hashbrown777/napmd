{"version":3,"file":"syntax.js","sources":["../../../node_modules/micromark-extension-gfm-task-list-item/lib/syntax.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').ConstructRecord} ConstructRecord\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Previous} Previous\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').Code} Code\n */\nimport {factorySpace} from 'micromark-factory-space'\nimport {\n  markdownSpace,\n  markdownLineEndingOrSpace\n} from 'micromark-util-character'\nconst tasklistCheck = {\n  tokenize: tokenizeTasklistCheck\n}\nexport const gfmTaskListItem = {\n  text: {\n    [91]: tasklistCheck\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeTasklistCheck(effects, ok, nok) {\n  const self = this\n  return open\n  /** @type {State} */\n\n  function open(code) {\n    if (\n      // Exit if thereâ€™s stuff before.\n      self.previous !== null || // Exit if not in the first content that is the first child of a list\n      // item.\n      !self._gfmTasklistFirstContentOfListItem\n    ) {\n      return nok(code)\n    }\n\n    effects.enter('taskListCheck')\n    effects.enter('taskListCheckMarker')\n    effects.consume(code)\n    effects.exit('taskListCheckMarker')\n    return inside\n  }\n  /** @type {State} */\n\n  function inside(code) {\n    if (markdownSpace(code)) {\n      effects.enter('taskListCheckValueUnchecked')\n      effects.consume(code)\n      effects.exit('taskListCheckValueUnchecked')\n      return close\n    }\n\n    if (code === 88 || code === 120) {\n      effects.enter('taskListCheckValueChecked')\n      effects.consume(code)\n      effects.exit('taskListCheckValueChecked')\n      return close\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function close(code) {\n    if (code === 93) {\n      effects.enter('taskListCheckMarker')\n      effects.consume(code)\n      effects.exit('taskListCheckMarker')\n      effects.exit('taskListCheck')\n      return effects.check(\n        {\n          tokenize: spaceThenNonSpace\n        },\n        ok,\n        nok\n      )\n    }\n\n    return nok(code)\n  }\n}\n/** @type {Tokenizer} */\n\nfunction spaceThenNonSpace(effects, ok, nok) {\n  const self = this\n  return factorySpace(effects, after, 'whitespace')\n  /** @type {State} */\n\n  function after(code) {\n    const tail = self.events[self.events.length - 1]\n    return tail &&\n      tail[1].type === 'whitespace' &&\n      code !== null &&\n      !markdownLineEndingOrSpace(code)\n      ? ok(code)\n      : nok(code)\n  }\n}\n"],"names":["gfmTaskListItem","text","tokenize","effects","ok","nok","self","this","code","previous","_gfmTasklistFirstContentOfListItem","enter","consume","exit","inside","markdownSpace","close","check","spaceThenNonSpace","factorySpace","tail","events","length","type","markdownLineEndingOrSpace"],"mappings":"yFAcA,MAGaA,EAAkB,CAC7BC,KAAM,CACJ,GALkB,CACpBC,SASF,SAA+BC,EAASC,EAAIC,GAC1C,MAAMC,EAAOC,KACb,OAGA,SAAcC,GACZ,GAEoB,OAAlBF,EAAKG,WAEJH,EAAKI,mCAEN,OAAOL,EAAIG,GAOb,OAJAL,EAAQQ,MAAM,iBACdR,EAAQQ,MAAM,uBACdR,EAAQS,QAAQJ,GAChBL,EAAQU,KAAK,uBACNC,GAIT,SAASA,EAAON,GACd,OAAIO,gBAAcP,IAChBL,EAAQQ,MAAM,+BACdR,EAAQS,QAAQJ,GAChBL,EAAQU,KAAK,+BACNG,GAGI,KAATR,GAAwB,MAATA,GACjBL,EAAQQ,MAAM,6BACdR,EAAQS,QAAQJ,GAChBL,EAAQU,KAAK,6BACNG,GAGFX,EAAIG,GAIb,SAASQ,EAAMR,GACb,OAAa,KAATA,GACFL,EAAQQ,MAAM,uBACdR,EAAQS,QAAQJ,GAChBL,EAAQU,KAAK,uBACbV,EAAQU,KAAK,iBACNV,EAAQc,MACb,CACEf,SAAUgB,GAEZd,EACAC,IAIGA,EAAIG,QAKf,SAASU,EAAkBf,EAASC,EAAIC,GACtC,MAAMC,EAAOC,KACb,OAAOY,eAAahB,GAGpB,SAAeK,GACb,MAAMY,EAAOd,EAAKe,OAAOf,EAAKe,OAAOC,OAAS,GAC9C,OAAOF,GACY,eAAjBA,EAAK,GAAGG,MACC,OAATf,IACCgB,4BAA0BhB,GACzBJ,EAAGI,GACHH,EAAIG,KAV0B"}