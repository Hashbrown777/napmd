{"version":3,"file":"syntax.js","sources":["../../../node_modules/micromark-extension-gfm-table/lib/syntax.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n */\n\n/**\n * @typedef {'left'|'center'|'right'|null} Align\n */\nimport {factorySpace} from 'micromark-factory-space'\nimport {\n  markdownLineEnding,\n  markdownLineEndingOrSpace,\n  markdownSpace\n} from 'micromark-util-character'\n\n/** @type {Extension} */\nexport const gfmTable = {\n  flow: {\n    null: {\n      tokenize: tokenizeTable,\n      resolve: resolveTable\n    }\n  }\n}\nconst setextUnderlineMini = {\n  tokenize: tokenizeSetextUnderlineMini,\n  partial: true\n}\nconst nextPrefixedOrBlank = {\n  tokenize: tokenizeNextPrefixedOrBlank,\n  partial: true\n}\n/** @type {Resolver} */\n\nfunction resolveTable(events, context) {\n  let index = -1\n  /** @type {boolean|undefined} */\n\n  let inHead\n  /** @type {boolean|undefined} */\n\n  let inDelimiterRow\n  /** @type {boolean|undefined} */\n\n  let inRow\n  /** @type {number|undefined} */\n\n  let contentStart\n  /** @type {number|undefined} */\n\n  let contentEnd\n  /** @type {number|undefined} */\n\n  let cellStart\n\n  while (++index < events.length) {\n    const token = events[index][1]\n\n    if (inRow) {\n      if (token.type === 'temporaryTableCellContent') {\n        contentStart = contentStart || index\n        contentEnd = index\n      }\n\n      if (\n        // Combine separate content parts into one.\n        (token.type === 'tableCellDivider' || token.type === 'tableRow') &&\n        contentEnd\n      ) {\n        const content = {\n          type: 'tableContent',\n          start: events[contentStart][1].start,\n          end: events[contentEnd][1].end\n        }\n        /** @type {Token} */\n\n        const text = {\n          type: 'chunkText',\n          start: content.start,\n          end: content.end,\n          // @ts-expect-error It’s fine.\n          contentType: 'text'\n        }\n        events.splice(\n          contentStart,\n          contentEnd - contentStart + 1,\n          ['enter', content, context],\n          ['enter', text, context],\n          ['exit', text, context],\n          ['exit', content, context]\n        )\n        index -= contentEnd - contentStart - 3\n        contentStart = undefined\n        contentEnd = undefined\n      }\n    }\n\n    if (\n      events[index][0] === 'exit' &&\n      cellStart &&\n      cellStart + 1 < index &&\n      (token.type === 'tableCellDivider' ||\n        (token.type === 'tableRow' &&\n          (cellStart + 3 < index ||\n            events[cellStart][1].type !== 'whitespace')))\n    ) {\n      const cell = {\n        type: inDelimiterRow\n          ? 'tableDelimiter'\n          : inHead\n          ? 'tableHeader'\n          : 'tableData',\n        start: events[cellStart][1].start,\n        end: events[index][1].end\n      }\n      events.splice(index + (token.type === 'tableCellDivider' ? 1 : 0), 0, [\n        'exit',\n        cell,\n        context\n      ])\n      events.splice(cellStart, 0, ['enter', cell, context])\n      index += 2\n      cellStart = index + 1\n    }\n\n    if (token.type === 'tableRow') {\n      inRow = events[index][0] === 'enter'\n\n      if (inRow) {\n        cellStart = index + 1\n      }\n    }\n\n    if (token.type === 'tableDelimiterRow') {\n      inDelimiterRow = events[index][0] === 'enter'\n\n      if (inDelimiterRow) {\n        cellStart = index + 1\n      }\n    }\n\n    if (token.type === 'tableHead') {\n      inHead = events[index][0] === 'enter'\n    }\n  }\n\n  return events\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeTable(effects, ok, nok) {\n  const self = this\n  /** @type {Align[]} */\n\n  const align = []\n  let tableHeaderCount = 0\n  /** @type {boolean|undefined} */\n\n  let seenDelimiter\n  /** @type {boolean|undefined} */\n\n  let hasDash\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    // @ts-expect-error Custom.\n    effects.enter('table')._align = align\n    effects.enter('tableHead')\n    effects.enter('tableRow') // If we start with a pipe, we open a cell marker.\n\n    if (code === 124) {\n      return cellDividerHead(code)\n    }\n\n    tableHeaderCount++\n    effects.enter('temporaryTableCellContent') // Can’t be space or eols at the start of a construct, so we’re in a cell.\n\n    return inCellContentHead(code)\n  }\n  /** @type {State} */\n\n  function cellDividerHead(code) {\n    effects.enter('tableCellDivider')\n    effects.consume(code)\n    effects.exit('tableCellDivider')\n    seenDelimiter = true\n    return cellBreakHead\n  }\n  /** @type {State} */\n\n  function cellBreakHead(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return atRowEndHead(code)\n    }\n\n    if (markdownSpace(code)) {\n      effects.enter('whitespace')\n      effects.consume(code)\n      return inWhitespaceHead\n    }\n\n    if (seenDelimiter) {\n      seenDelimiter = undefined\n      tableHeaderCount++\n    }\n\n    if (code === 124) {\n      return cellDividerHead(code)\n    } // Anything else is cell content.\n\n    effects.enter('temporaryTableCellContent')\n    return inCellContentHead(code)\n  }\n  /** @type {State} */\n\n  function inWhitespaceHead(code) {\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return inWhitespaceHead\n    }\n\n    effects.exit('whitespace')\n    return cellBreakHead(code)\n  }\n  /** @type {State} */\n\n  function inCellContentHead(code) {\n    // EOF, whitespace, pipe\n    if (code === null || code === 124 || markdownLineEndingOrSpace(code)) {\n      effects.exit('temporaryTableCellContent')\n      return cellBreakHead(code)\n    }\n\n    effects.consume(code)\n    return code === 92 ? inCellContentEscapeHead : inCellContentHead\n  }\n  /** @type {State} */\n\n  function inCellContentEscapeHead(code) {\n    if (code === 92 || code === 124) {\n      effects.consume(code)\n      return inCellContentHead\n    } // Anything else.\n\n    return inCellContentHead(code)\n  }\n  /** @type {State} */\n\n  function atRowEndHead(code) {\n    if (code === null) {\n      return nok(code)\n    }\n\n    effects.exit('tableRow')\n    effects.exit('tableHead')\n    return effects.attempt(\n      {\n        tokenize: tokenizeRowEnd,\n        partial: true\n      },\n      atDelimiterLineStart,\n      nok\n    )(code)\n  }\n  /** @type {State} */\n\n  function atDelimiterLineStart(code) {\n    return effects.check(\n      setextUnderlineMini,\n      nok, // Support an indent before the delimiter row.\n      factorySpace(effects, rowStartDelimiter, 'linePrefix', 4)\n    )(code)\n  }\n  /** @type {State} */\n\n  function rowStartDelimiter(code) {\n    // If there’s another space, or we’re at the EOL/EOF, exit.\n    if (code === null || markdownLineEndingOrSpace(code)) {\n      return nok(code)\n    }\n\n    effects.enter('tableDelimiterRow')\n    return atDelimiterRowBreak(code)\n  }\n  /** @type {State} */\n\n  function atDelimiterRowBreak(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return rowEndDelimiter(code)\n    }\n\n    if (markdownSpace(code)) {\n      effects.enter('whitespace')\n      effects.consume(code)\n      return inWhitespaceDelimiter\n    }\n\n    if (code === 45) {\n      effects.enter('tableDelimiterFiller')\n      effects.consume(code)\n      hasDash = true\n      align.push(null)\n      return inFillerDelimiter\n    }\n\n    if (code === 58) {\n      effects.enter('tableDelimiterAlignment')\n      effects.consume(code)\n      effects.exit('tableDelimiterAlignment')\n      align.push('left')\n      return afterLeftAlignment\n    } // If we start with a pipe, we open a cell marker.\n\n    if (code === 124) {\n      effects.enter('tableCellDivider')\n      effects.consume(code)\n      effects.exit('tableCellDivider')\n      return atDelimiterRowBreak\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function inWhitespaceDelimiter(code) {\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return inWhitespaceDelimiter\n    }\n\n    effects.exit('whitespace')\n    return atDelimiterRowBreak(code)\n  }\n  /** @type {State} */\n\n  function inFillerDelimiter(code) {\n    if (code === 45) {\n      effects.consume(code)\n      return inFillerDelimiter\n    }\n\n    effects.exit('tableDelimiterFiller')\n\n    if (code === 58) {\n      effects.enter('tableDelimiterAlignment')\n      effects.consume(code)\n      effects.exit('tableDelimiterAlignment')\n      align[align.length - 1] =\n        align[align.length - 1] === 'left' ? 'center' : 'right'\n      return afterRightAlignment\n    }\n\n    return atDelimiterRowBreak(code)\n  }\n  /** @type {State} */\n\n  function afterLeftAlignment(code) {\n    if (code === 45) {\n      effects.enter('tableDelimiterFiller')\n      effects.consume(code)\n      hasDash = true\n      return inFillerDelimiter\n    } // Anything else is not ok.\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function afterRightAlignment(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return rowEndDelimiter(code)\n    }\n\n    if (markdownSpace(code)) {\n      effects.enter('whitespace')\n      effects.consume(code)\n      return inWhitespaceDelimiter\n    } // `|`\n\n    if (code === 124) {\n      effects.enter('tableCellDivider')\n      effects.consume(code)\n      effects.exit('tableCellDivider')\n      return atDelimiterRowBreak\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function rowEndDelimiter(code) {\n    effects.exit('tableDelimiterRow') // Exit if there was no dash at all, or if the header cell count is not the\n    // delimiter cell count.\n\n    if (!hasDash || tableHeaderCount !== align.length) {\n      return nok(code)\n    }\n\n    if (code === null) {\n      return tableClose(code)\n    }\n\n    return effects.check(\n      nextPrefixedOrBlank,\n      tableClose,\n      effects.attempt(\n        {\n          tokenize: tokenizeRowEnd,\n          partial: true\n        },\n        factorySpace(effects, bodyStart, 'linePrefix', 4),\n        tableClose\n      )\n    )(code)\n  }\n  /** @type {State} */\n\n  function tableClose(code) {\n    effects.exit('table')\n    return ok(code)\n  }\n  /** @type {State} */\n\n  function bodyStart(code) {\n    effects.enter('tableBody')\n    return rowStartBody(code)\n  }\n  /** @type {State} */\n\n  function rowStartBody(code) {\n    effects.enter('tableRow') // If we start with a pipe, we open a cell marker.\n\n    if (code === 124) {\n      return cellDividerBody(code)\n    }\n\n    effects.enter('temporaryTableCellContent') // Can’t be space or eols at the start of a construct, so we’re in a cell.\n\n    return inCellContentBody(code)\n  }\n  /** @type {State} */\n\n  function cellDividerBody(code) {\n    effects.enter('tableCellDivider')\n    effects.consume(code)\n    effects.exit('tableCellDivider')\n    return cellBreakBody\n  }\n  /** @type {State} */\n\n  function cellBreakBody(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return atRowEndBody(code)\n    }\n\n    if (markdownSpace(code)) {\n      effects.enter('whitespace')\n      effects.consume(code)\n      return inWhitespaceBody\n    } // `|`\n\n    if (code === 124) {\n      return cellDividerBody(code)\n    } // Anything else is cell content.\n\n    effects.enter('temporaryTableCellContent')\n    return inCellContentBody(code)\n  }\n  /** @type {State} */\n\n  function inWhitespaceBody(code) {\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return inWhitespaceBody\n    }\n\n    effects.exit('whitespace')\n    return cellBreakBody(code)\n  }\n  /** @type {State} */\n\n  function inCellContentBody(code) {\n    // EOF, whitespace, pipe\n    if (code === null || code === 124 || markdownLineEndingOrSpace(code)) {\n      effects.exit('temporaryTableCellContent')\n      return cellBreakBody(code)\n    }\n\n    effects.consume(code)\n    return code === 92 ? inCellContentEscapeBody : inCellContentBody\n  }\n  /** @type {State} */\n\n  function inCellContentEscapeBody(code) {\n    if (code === 92 || code === 124) {\n      effects.consume(code)\n      return inCellContentBody\n    } // Anything else.\n\n    return inCellContentBody(code)\n  }\n  /** @type {State} */\n\n  function atRowEndBody(code) {\n    effects.exit('tableRow')\n\n    if (code === null) {\n      return tableBodyClose(code)\n    }\n\n    return effects.check(\n      nextPrefixedOrBlank,\n      tableBodyClose,\n      effects.attempt(\n        {\n          tokenize: tokenizeRowEnd,\n          partial: true\n        },\n        factorySpace(effects, rowStartBody, 'linePrefix', 4),\n        tableBodyClose\n      )\n    )(code)\n  }\n  /** @type {State} */\n\n  function tableBodyClose(code) {\n    effects.exit('tableBody')\n    return tableClose(code)\n  }\n  /** @type {Tokenizer} */\n\n  function tokenizeRowEnd(effects, ok, nok) {\n    return start\n    /** @type {State} */\n\n    function start(code) {\n      effects.enter('lineEnding')\n      effects.consume(code)\n      effects.exit('lineEnding')\n      return lineStart\n    }\n    /** @type {State} */\n\n    function lineStart(code) {\n      return self.parser.lazy[self.now().line] ? nok(code) : ok(code)\n    }\n  }\n} // Based on micromark, but that won’t work as we’re in a table, and that expects\n// content.\n// <https://github.com/micromark/micromark/blob/main/lib/tokenize/setext-underline.js>\n\n/** @type {Tokenizer} */\n\nfunction tokenizeSetextUnderlineMini(effects, ok, nok) {\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    if (code !== 45) {\n      return nok(code)\n    }\n\n    effects.enter('setextUnderline')\n    return sequence(code)\n  }\n  /** @type {State} */\n\n  function sequence(code) {\n    if (code === 45) {\n      effects.consume(code)\n      return sequence\n    }\n\n    return whitespace(code)\n  }\n  /** @type {State} */\n\n  function whitespace(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return ok(code)\n    }\n\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return whitespace\n    }\n\n    return nok(code)\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeNextPrefixedOrBlank(effects, ok, nok) {\n  let size = 0\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    // This is a check, so we don’t care about tokens, but we open a bogus one\n    // so we’re valid.\n    effects.enter('check') // EOL.\n\n    effects.consume(code)\n    return whitespace\n  }\n  /** @type {State} */\n\n  function whitespace(code) {\n    if (code === -1 || code === 32) {\n      effects.consume(code)\n      size++\n      return size === 4 ? ok : whitespace\n    } // EOF or whitespace\n\n    if (code === null || markdownLineEndingOrSpace(code)) {\n      return ok(code)\n    } // Anything else.\n\n    return nok(code)\n  }\n}\n"],"names":["gfmTable","flow","null","tokenize","effects","ok","nok","self","this","align","seenDelimiter","hasDash","tableHeaderCount","code","enter","_align","cellDividerHead","inCellContentHead","consume","exit","cellBreakHead","markdownLineEnding","attempt","tokenizeRowEnd","partial","atDelimiterLineStart","atRowEndHead","markdownSpace","inWhitespaceHead","undefined","markdownLineEndingOrSpace","inCellContentEscapeHead","check","setextUnderlineMini","factorySpace","rowStartDelimiter","atDelimiterRowBreak","rowEndDelimiter","inWhitespaceDelimiter","push","inFillerDelimiter","afterLeftAlignment","length","afterRightAlignment","tableClose","nextPrefixedOrBlank","bodyStart","rowStartBody","cellDividerBody","inCellContentBody","cellBreakBody","tableBodyClose","atRowEndBody","inWhitespaceBody","inCellContentEscapeBody","lineStart","parser","lazy","now","line","resolve","events","context","inHead","inDelimiterRow","inRow","contentStart","contentEnd","cellStart","index","token","type","content","start","end","text","contentType","splice","cell","sequence","whitespace","size"],"mappings":"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"}