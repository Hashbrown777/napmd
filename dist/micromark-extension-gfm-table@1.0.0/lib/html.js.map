{"version":3,"file":"html.js","sources":["../../../node_modules/micromark-extension-gfm-table/lib/html.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').HtmlExtension} HtmlExtension\n */\n\n/**\n * @typedef {import('./syntax.js').Align} Align\n */\nconst alignment = {\n  null: '',\n  left: ' align=\"left\"',\n  right: ' align=\"right\"',\n  center: ' align=\"center\"'\n}\n/** @type {HtmlExtension} */\n\nexport const gfmTableHtml = {\n  enter: {\n    table(token) {\n      this.lineEndingIfNeeded()\n      this.tag('<table>') // @ts-expect-error Custom.\n\n      this.setData('tableAlign', token._align)\n    },\n\n    tableBody() {\n      // Clear slurping line ending from the delimiter row.\n      this.setData('slurpOneLineEnding')\n      this.tag('<tbody>')\n    },\n\n    tableData() {\n      /** @type {string|undefined} */\n      const align = // @ts-expect-error Custom.\n        alignment[this.getData('tableAlign')[this.getData('tableColumn')]]\n\n      if (align === undefined) {\n        // Capture results to ignore them.\n        this.buffer()\n      } else {\n        this.lineEndingIfNeeded()\n        this.tag('<td' + align + '>')\n      }\n    },\n\n    tableHead() {\n      this.lineEndingIfNeeded()\n      this.tag('<thead>')\n    },\n\n    tableHeader() {\n      this.lineEndingIfNeeded()\n      this.tag(\n        '<th' + // @ts-expect-error Custom.\n          alignment[this.getData('tableAlign')[this.getData('tableColumn')]] +\n          '>'\n      )\n    },\n\n    tableRow() {\n      this.setData('tableColumn', 0)\n      this.lineEndingIfNeeded()\n      this.tag('<tr>')\n    }\n  },\n  exit: {\n    // Overwrite the default code text data handler to unescape escaped pipes when\n    // they are in tables.\n    codeTextData(token) {\n      let value = this.sliceSerialize(token)\n\n      if (this.getData('tableAlign')) {\n        value = value.replace(/\\\\([\\\\|])/g, replace)\n      }\n\n      this.raw(this.encode(value))\n    },\n\n    table() {\n      this.setData('tableAlign') // If there was no table body, make sure the slurping from the delimiter row\n      // is cleared.\n\n      this.setData('slurpAllLineEndings')\n      this.lineEndingIfNeeded()\n      this.tag('</table>')\n    },\n\n    tableBody() {\n      this.lineEndingIfNeeded()\n      this.tag('</tbody>')\n    },\n\n    tableData() {\n      /** @type {number} */\n      // @ts-expect-error Custom.\n      const column = this.getData('tableColumn') // @ts-expect-error Custom.\n\n      if (column in this.getData('tableAlign')) {\n        this.tag('</td>')\n        this.setData('tableColumn', column + 1)\n      } else {\n        // Stop capturing.\n        this.resume()\n      }\n    },\n\n    tableHead() {\n      this.lineEndingIfNeeded()\n      this.tag('</thead>')\n      this.setData('slurpOneLineEnding', true) // Slurp the line ending from the delimiter row.\n    },\n\n    tableHeader() {\n      this.tag('</th>') // @ts-expect-error Custom.\n\n      this.setData('tableColumn', this.getData('tableColumn') + 1)\n    },\n\n    tableRow() {\n      /** @type {Align[]} */\n      // @ts-expect-error Custom.\n      const align = this.getData('tableAlign')\n      /** @type {number} */\n      // @ts-expect-error Custom.\n\n      let column = this.getData('tableColumn')\n\n      while (column < align.length) {\n        this.lineEndingIfNeeded() // @ts-expect-error `null` is fine as an index.\n\n        this.tag('<td' + alignment[align[column]] + '></td>')\n        column++\n      }\n\n      this.setData('tableColumn', column)\n      this.lineEndingIfNeeded()\n      this.tag('</tr>')\n    }\n  }\n}\n/**\n * @param {string} $0\n * @param {string} $1\n * @returns {string}\n */\n\nfunction replace($0, $1) {\n  // Pipes work, backslashes don’t (but can’t escape pipes).\n  return $1 === '|' ? $1 : $0\n}\n"],"names":["alignment","null","left","right","center","gfmTableHtml","enter","table","token","this","lineEndingIfNeeded","tag","setData","_align","tableBody","tableData","align","getData","undefined","buffer","tableHead","tableHeader","tableRow","exit","codeTextData","value","sliceSerialize","replace","raw","encode","column","resume","length","$0","$1"],"mappings":"gCAOA,MAAMA,EAAY,CAChBC,KAAM,GACNC,KAAM,gBACNC,MAAO,iBACPC,OAAQ,mBAIGC,EAAe,CAC1BC,MAAO,CACLC,MAAMC,GACJC,KAAKC,qBACLD,KAAKE,IAAI,WAETF,KAAKG,QAAQ,aAAcJ,EAAMK,SAGnCC,YAEEL,KAAKG,QAAQ,sBACbH,KAAKE,IAAI,YAGXI,YAEE,MAAMC,EACJhB,EAAUS,KAAKQ,QAAQ,cAAcR,KAAKQ,QAAQ,sBAEtCC,IAAVF,EAEFP,KAAKU,UAELV,KAAKC,qBACLD,KAAKE,IAAI,MAAQK,EAAQ,OAI7BI,YACEX,KAAKC,qBACLD,KAAKE,IAAI,YAGXU,cACEZ,KAAKC,qBACLD,KAAKE,IACH,MACEX,EAAUS,KAAKQ,QAAQ,cAAcR,KAAKQ,QAAQ,iBAClD,MAINK,WACEb,KAAKG,QAAQ,cAAe,GAC5BH,KAAKC,qBACLD,KAAKE,IAAI,UAGbY,KAAM,CAGJC,aAAahB,GACX,IAAIiB,EAAQhB,KAAKiB,eAAelB,GAE5BC,KAAKQ,QAAQ,gBACfQ,EAAQA,EAAME,QAAQ,aAAcA,IAGtClB,KAAKmB,IAAInB,KAAKoB,OAAOJ,KAGvBlB,QACEE,KAAKG,QAAQ,cAGbH,KAAKG,QAAQ,uBACbH,KAAKC,qBACLD,KAAKE,IAAI,aAGXG,YACEL,KAAKC,qBACLD,KAAKE,IAAI,aAGXI,YAGE,MAAMe,EAASrB,KAAKQ,QAAQ,eAExBa,KAAUrB,KAAKQ,QAAQ,eACzBR,KAAKE,IAAI,SACTF,KAAKG,QAAQ,cAAekB,EAAS,IAGrCrB,KAAKsB,UAITX,YACEX,KAAKC,qBACLD,KAAKE,IAAI,YACTF,KAAKG,QAAQ,sBAAsB,IAGrCS,cACEZ,KAAKE,IAAI,SAETF,KAAKG,QAAQ,cAAeH,KAAKQ,QAAQ,eAAiB,IAG5DK,WAGE,MAAMN,EAAQP,KAAKQ,QAAQ,cAI3B,IAAIa,EAASrB,KAAKQ,QAAQ,eAE1B,KAAOa,EAASd,EAAMgB,QACpBvB,KAAKC,qBAELD,KAAKE,IAAI,MAAQX,EAAUgB,EAAMc,IAAW,UAC5CA,IAGFrB,KAAKG,QAAQ,cAAekB,GAC5BrB,KAAKC,qBACLD,KAAKE,IAAI,YAUf,SAASgB,EAAQM,EAAIC,GAEnB,MAAc,MAAPA,EAAaA,EAAKD"}