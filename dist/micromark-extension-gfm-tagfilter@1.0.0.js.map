{"version":3,"file":"micromark-extension-gfm-tagfilter@1.0.0.js","sources":["../node_modules/micromark-extension-gfm-tagfilter/index.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').HtmlExtension} HtmlExtension\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').CompileContext} CompileContext\n */\n\n/**\n * An opening or closing tag, followed by a case-insensitive specific tag name,\n * followed by HTML whitespace, a greater than, or a slash.\n */\nconst reFlow =\n  /<(\\/?)(iframe|noembed|noframes|plaintext|script|style|title|textarea|xmp)(?=[\\t\\n\\f\\r />])/gi\n\n/**\n * As HTML (text) parses tags separately (and v. strictly), we donâ€™t need to be\n * global.\n */\nconst reText = new RegExp('^' + reFlow.source, 'i')\n\n/** @type {HtmlExtension} */\nexport const gfmTagfilterHtml = {\n  exit: {\n    htmlFlowData(token) {\n      exitHtmlData.call(this, token, reFlow)\n    },\n    htmlTextData(token) {\n      exitHtmlData.call(this, token, reText)\n    }\n  }\n}\n\n/**\n * @this {CompileContext}\n * @param {Token} token\n * @param {RegExp} filter\n */\nfunction exitHtmlData(token, filter) {\n  let value = this.sliceSerialize(token)\n\n  if (this.options.allowDangerousHtml) {\n    value = value.replace(filter, '&lt;$1$2')\n  }\n\n  this.raw(this.encode(value))\n}\n"],"names":["reFlow","reText","RegExp","source","gfmTagfilterHtml","exit","htmlFlowData","token","exitHtmlData","call","this","htmlTextData","filter","value","sliceSerialize","options","allowDangerousHtml","replace","raw","encode"],"mappings":"gCAUA,MAAMA,EACJ,+FAMIC,EAAS,IAAIC,OAAO,IAAMF,EAAOG,OAAQ,KAGlCC,EAAmB,CAC9BC,KAAM,CACJC,aAAaC,GACXC,EAAaC,KAAKC,KAAMH,EAAOP,IAEjCW,aAAaJ,GACXC,EAAaC,KAAKC,KAAMH,EAAON,MAUrC,SAASO,EAAaD,EAAOK,GAC3B,IAAIC,EAAQH,KAAKI,eAAeP,GAE5BG,KAAKK,QAAQC,qBACfH,EAAQA,EAAMI,QAAQL,EAAQ,aAGhCF,KAAKQ,IAAIR,KAAKS,OAAON"}