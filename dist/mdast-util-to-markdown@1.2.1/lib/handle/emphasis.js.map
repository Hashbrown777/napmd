{"version":3,"file":"emphasis.js","sources":["../../../../node_modules/mdast-util-to-markdown/lib/handle/emphasis.js"],"sourcesContent":["/**\n * @typedef {import('mdast').Emphasis} Emphasis\n * @typedef {import('../types.js').Handle} Handle\n */\n\nimport {checkEmphasis} from '../util/check-emphasis.js'\nimport {containerPhrasing} from '../util/container-phrasing.js'\n\nemphasis.peek = emphasisPeek\n\n// To do: there are cases where emphasis cannot “form” depending on the\n// previous or next character of sequences.\n// There’s no way around that though, except for injecting zero-width stuff.\n// Do we need to safeguard against that?\n/**\n * @type {Handle}\n * @param {Emphasis} node\n */\nexport function emphasis(node, _, context) {\n  const marker = checkEmphasis(context)\n  const exit = context.enter('emphasis')\n  const value = containerPhrasing(node, context, {\n    before: marker,\n    after: marker\n  })\n  exit()\n  return marker + value + marker\n}\n\n/**\n * @type {Handle}\n * @param {Emphasis} _\n */\nfunction emphasisPeek(_, _1, context) {\n  return context.options.emphasis || '*'\n}\n"],"names":["emphasis","node","_","context","marker","checkEmphasis","exit","enter","value","containerPhrasing","before","after","peek","_1","options"],"mappings":"0FAkBO,SAASA,EAASC,EAAMC,EAAGC,GAChC,MAAMC,EAASC,gBAAcF,GACvBG,EAAOH,EAAQI,MAAM,YACrBC,EAAQC,oBAAkBR,EAAME,EAAS,CAC7CO,OAAQN,EACRO,MAAOP,IAGT,OADAE,IACOF,EAASI,EAAQJ,EAlB1BJ,EAASY,KAyBT,SAAsBV,EAAGW,EAAIV,GAC3B,OAAOA,EAAQW,QAAQd,UAAY"}