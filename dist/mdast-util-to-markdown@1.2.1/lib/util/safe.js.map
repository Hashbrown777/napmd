{"version":3,"file":"safe.js","sources":["../../../../node_modules/mdast-util-to-markdown/lib/util/safe.js"],"sourcesContent":["/**\n * @typedef {import('../types.js').Context} Context\n * @typedef {import('../types.js').SafeOptions} SafeOptions\n */\n\nimport {patternCompile} from './pattern-compile.js'\nimport {patternInScope} from './pattern-in-scope.js'\n\n/**\n * @param {Context} context\n * @param {string|null|undefined} input\n * @param {SafeOptions & {encode?: Array.<string>}} config\n * @returns {string}\n */\nexport function safe(context, input, config) {\n  const value = (config.before || '') + (input || '') + (config.after || '')\n  /** @type {Array.<number>} */\n  const positions = []\n  /** @type {Array.<string>} */\n  const result = []\n  /** @type {Record<number, {before: boolean, after: boolean}>} */\n  const infos = {}\n  let index = -1\n\n  while (++index < context.unsafe.length) {\n    const pattern = context.unsafe[index]\n\n    if (!patternInScope(context.stack, pattern)) {\n      continue\n    }\n\n    const expression = patternCompile(pattern)\n    /** @type {RegExpExecArray|null} */\n    let match\n\n    while ((match = expression.exec(value))) {\n      const before = 'before' in pattern || Boolean(pattern.atBreak)\n      const after = 'after' in pattern\n      const position = match.index + (before ? match[1].length : 0)\n\n      if (positions.includes(position)) {\n        if (infos[position].before && !before) {\n          infos[position].before = false\n        }\n\n        if (infos[position].after && !after) {\n          infos[position].after = false\n        }\n      } else {\n        positions.push(position)\n        infos[position] = {before, after}\n      }\n    }\n  }\n\n  positions.sort(numerical)\n\n  let start = config.before ? config.before.length : 0\n  const end = value.length - (config.after ? config.after.length : 0)\n  index = -1\n\n  while (++index < positions.length) {\n    const position = positions[index]\n\n    // Character before or after matched:\n    if (position < start || position >= end) {\n      continue\n    }\n\n    // If this character is supposed to be escaped because it has a condition on\n    // the next character, and the next character is definitly being escaped,\n    // then skip this escape.\n    if (\n      (position + 1 < end &&\n        positions[index + 1] === position + 1 &&\n        infos[position].after &&\n        !infos[position + 1].before &&\n        !infos[position + 1].after) ||\n      (positions[index - 1] === position - 1 &&\n        infos[position].before &&\n        !infos[position - 1].before &&\n        !infos[position - 1].after)\n    ) {\n      continue\n    }\n\n    if (start !== position) {\n      // If we have to use a character reference, an ampersand would be more\n      // correct, but as backslashes only care about punctuation, either will\n      // do the trick\n      result.push(escapeBackslashes(value.slice(start, position), '\\\\'))\n    }\n\n    start = position\n\n    if (\n      /[!-/:-@[-`{-~]/.test(value.charAt(position)) &&\n      (!config.encode || !config.encode.includes(value.charAt(position)))\n    ) {\n      // Character escape.\n      result.push('\\\\')\n    } else {\n      // Character reference.\n      result.push(\n        '&#x' + value.charCodeAt(position).toString(16).toUpperCase() + ';'\n      )\n      start++\n    }\n  }\n\n  result.push(escapeBackslashes(value.slice(start, end), config.after))\n\n  return result.join('')\n}\n\n/**\n * @param {number} a\n * @param {number} b\n * @returns {number}\n */\nfunction numerical(a, b) {\n  return a - b\n}\n\n/**\n * @param {string} value\n * @param {string} after\n * @returns {string}\n */\nfunction escapeBackslashes(value, after) {\n  const expression = /\\\\(?=[!-/:-@[-`{-~])/g\n  /** @type {Array.<number>} */\n  const positions = []\n  /** @type {Array.<string>} */\n  const results = []\n  const whole = value + after\n  let index = -1\n  let start = 0\n  /** @type {RegExpExecArray|null} */\n  let match\n\n  while ((match = expression.exec(whole))) {\n    positions.push(match.index)\n  }\n\n  while (++index < positions.length) {\n    if (start !== positions[index]) {\n      results.push(value.slice(start, positions[index]))\n    }\n\n    results.push('\\\\')\n    start = positions[index]\n  }\n\n  results.push(value.slice(start))\n\n  return results.join('')\n}\n"],"names":["numerical","a","b","escapeBackslashes","value","after","expression","positions","results","whole","match","index","start","exec","push","length","slice","join","context","input","config","before","result","infos","unsafe","pattern","patternInScope","stack","patternCompile","Boolean","atBreak","position","includes","sort","end","test","charAt","encode","charCodeAt","toString","toUpperCase"],"mappings":"6EAwHA,SAASA,EAAUC,EAAGC,GACpB,OAAOD,EAAIC,EAQb,SAASC,EAAkBC,EAAOC,GAChC,MAAMC,EAAa,wBAEbC,EAAY,GAEZC,EAAU,GACVC,EAAQL,EAAQC,EACtB,IAGIK,EAHAC,GAAS,EACTC,EAAQ,EAIZ,KAAQF,EAAQJ,EAAWO,KAAKJ,IAC9BF,EAAUO,KAAKJ,EAAMC,OAGvB,OAASA,EAAQJ,EAAUQ,QACrBH,IAAUL,EAAUI,IACtBH,EAAQM,KAAKV,EAAMY,MAAMJ,EAAOL,EAAUI,KAG5CH,EAAQM,KAAK,MACbF,EAAQL,EAAUI,GAKpB,OAFAH,EAAQM,KAAKV,EAAMY,MAAMJ,IAElBJ,EAAQS,KAAK,WA9If,SAAcC,EAASC,EAAOC,GACnC,MAAMhB,GAASgB,EAAOC,QAAU,KAAOF,GAAS,KAAOC,EAAOf,OAAS,IAEjEE,EAAY,GAEZe,EAAS,GAETC,EAAQ,GACd,IAAIZ,GAAS,EAEb,OAASA,EAAQO,EAAQM,OAAOT,QAAQ,CACtC,MAAMU,EAAUP,EAAQM,OAAOb,GAE/B,IAAKe,iBAAeR,EAAQS,MAAOF,GACjC,SAGF,MAAMnB,EAAasB,iBAAeH,GAElC,IAAIf,EAEJ,KAAQA,EAAQJ,EAAWO,KAAKT,IAAS,CACvC,MAAMiB,EAAS,WAAYI,GAAWI,QAAQJ,EAAQK,SAChDzB,EAAQ,UAAWoB,EACnBM,EAAWrB,EAAMC,OAASU,EAASX,EAAM,GAAGK,OAAS,GAEvDR,EAAUyB,SAASD,IACjBR,EAAMQ,GAAUV,SAAWA,IAC7BE,EAAMQ,GAAUV,QAAS,GAGvBE,EAAMQ,GAAU1B,QAAUA,IAC5BkB,EAAMQ,GAAU1B,OAAQ,KAG1BE,EAAUO,KAAKiB,GACfR,EAAMQ,GAAY,CAACV,OAAAA,EAAQhB,MAAAA,KAKjCE,EAAU0B,KAAKjC,GAEf,IAAIY,EAAQQ,EAAOC,OAASD,EAAOC,OAAON,OAAS,EACnD,MAAMmB,EAAM9B,EAAMW,QAAUK,EAAOf,MAAQe,EAAOf,MAAMU,OAAS,GAGjE,IAFAJ,GAAS,IAEAA,EAAQJ,EAAUQ,QAAQ,CACjC,MAAMgB,EAAWxB,EAAUI,GAGvBoB,EAAWnB,GAASmB,GAAYG,IAQjCH,EAAW,EAAIG,GACd3B,EAAUI,EAAQ,KAAOoB,EAAW,GACpCR,EAAMQ,GAAU1B,QACfkB,EAAMQ,EAAW,GAAGV,SACpBE,EAAMQ,EAAW,GAAG1B,OACtBE,EAAUI,EAAQ,KAAOoB,EAAW,GACnCR,EAAMQ,GAAUV,SACfE,EAAMQ,EAAW,GAAGV,SACpBE,EAAMQ,EAAW,GAAG1B,QAKrBO,IAAUmB,GAIZT,EAAOR,KAAKX,EAAkBC,EAAMY,MAAMJ,EAAOmB,GAAW,OAG9DnB,EAAQmB,GAGN,iBAAiBI,KAAK/B,EAAMgC,OAAOL,KACjCX,EAAOiB,QAAWjB,EAAOiB,OAAOL,SAAS5B,EAAMgC,OAAOL,KAMxDT,EAAOR,KACL,MAAQV,EAAMkC,WAAWP,GAAUQ,SAAS,IAAIC,cAAgB,KAElE5B,KANAU,EAAOR,KAAK,QAYhB,OAFAQ,EAAOR,KAAKX,EAAkBC,EAAMY,MAAMJ,EAAOsB,GAAMd,EAAOf,QAEvDiB,EAAOL,KAAK"}