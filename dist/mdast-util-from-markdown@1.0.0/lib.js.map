{"version":3,"file":"lib.js","sources":["../../node_modules/mdast-util-from-markdown/lib/index.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Encoding} Encoding\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').ParseOptions} ParseOptions\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Value} Value\n * @typedef {import('unist').Parent} UnistParent\n * @typedef {import('unist').Point} Point\n * @typedef {import('mdast').PhrasingContent} PhrasingContent\n * @typedef {import('mdast').Content} Content\n * @typedef {Root|Content} Node\n * @typedef {Extract<Node, UnistParent>} Parent\n * @typedef {import('mdast').Break} Break\n * @typedef {import('mdast').Blockquote} Blockquote\n * @typedef {import('mdast').Code} Code\n * @typedef {import('mdast').Definition} Definition\n * @typedef {import('mdast').Emphasis} Emphasis\n * @typedef {import('mdast').Heading} Heading\n * @typedef {import('mdast').HTML} HTML\n * @typedef {import('mdast').Image} Image\n * @typedef {import('mdast').ImageReference} ImageReference\n * @typedef {import('mdast').InlineCode} InlineCode\n * @typedef {import('mdast').Link} Link\n * @typedef {import('mdast').LinkReference} LinkReference\n * @typedef {import('mdast').List} List\n * @typedef {import('mdast').ListItem} ListItem\n * @typedef {import('mdast').Paragraph} Paragraph\n * @typedef {import('mdast').Root} Root\n * @typedef {import('mdast').Strong} Strong\n * @typedef {import('mdast').Text} Text\n * @typedef {import('mdast').ThematicBreak} ThematicBreak\n *\n * @typedef {UnistParent & {type: 'fragment', children: PhrasingContent[]}} Fragment\n */\n\n/**\n * @typedef _CompileDataFields\n * @property {boolean|undefined} expectingFirstListItemValue\n * @property {boolean|undefined} flowCodeInside\n * @property {boolean|undefined} setextHeadingSlurpLineEnding\n * @property {boolean|undefined} atHardBreak\n * @property {'collapsed'|'full'} referenceType\n * @property {boolean|undefined} inReference\n * @property {'characterReferenceMarkerHexadecimal'|'characterReferenceMarkerNumeric'} characterReferenceType\n *\n * @typedef {Record<string, unknown> & Partial<_CompileDataFields>} CompileData\n *\n * @typedef {(tree: Root) => Root|void} Transform\n * @typedef {(this: CompileContext, token: Token) => void} Handle\n * @typedef {Record<string, Handle>} Handles\n *   Token types mapping to handles\n * @typedef {Record<string, Record<string, unknown>|Array.<unknown>> & {canContainEols: Array.<string>, transforms: Array.<Transform>, enter: Handles, exit: Handles}} NormalizedExtension\n * @typedef {Partial<NormalizedExtension>} Extension\n *   An mdast extension changes how markdown tokens are turned into mdast.\n *\n * @typedef CompileContext\n *   mdast compiler context\n * @property {Array.<Node | Fragment>} stack\n * @property {Array.<Token>} tokenStack\n * @property {(key: string, value?: unknown) => void} setData\n *   Set data into the key-value store.\n * @property {<K extends string>(key: K) => CompileData[K]} getData\n *   Get data from the key-value store.\n * @property {(this: CompileContext) => void} buffer\n *   Capture some of the output data.\n * @property {(this: CompileContext) => string} resume\n *   Stop capturing and access the output data.\n * @property {<N extends Node>(this: CompileContext, node: N, token: Token) => N} enter\n *   Enter a token.\n * @property {(this: CompileContext, token: Token) => Node} exit\n *   Exit a token.\n * @property {TokenizeContext['sliceSerialize']} sliceSerialize\n *   Get the string value of a token.\n * @property {NormalizedExtension} config\n *   Configuration.\n *\n * @typedef {{mdastExtensions?: Array.<Extension|Array.<Extension>>}} FromMarkdownOptions\n * @typedef {ParseOptions & FromMarkdownOptions} Options\n */\nimport {toString} from 'mdast-util-to-string'\nimport {parse} from 'micromark/lib/parse.js'\nimport {preprocess} from 'micromark/lib/preprocess.js'\nimport {postprocess} from 'micromark/lib/postprocess.js'\nimport {decodeNumericCharacterReference} from 'micromark-util-decode-numeric-character-reference'\nimport {decodeString} from 'micromark-util-decode-string'\nimport {normalizeIdentifier} from 'micromark-util-normalize-identifier'\nimport {decodeEntity} from 'parse-entities/decode-entity.js'\nimport {stringifyPosition} from 'unist-util-stringify-position'\nconst own = {}.hasOwnProperty\n/**\n * @param value Markdown to parse (`string` or `Buffer`).\n * @param [encoding] Character encoding to understand `value` as when it’s a `Buffer` (`string`, default: `'utf8'`).\n * @param [options] Configuration\n */\n\nexport const fromMarkdown =\n  /**\n   * @type {(\n   *   ((value: Value, encoding: Encoding, options?: Options) => Root) &\n   *   ((value: Value, options?: Options) => Root)\n   * )}\n   */\n\n  /**\n   * @param {Value} value\n   * @param {Encoding} [encoding]\n   * @param {Options} [options]\n   * @returns {Root}\n   */\n  function (value, encoding, options) {\n    if (typeof encoding !== 'string') {\n      options = encoding\n      encoding = undefined\n    }\n\n    return compiler(options)(\n      postprocess(\n        parse(options).document().write(preprocess()(value, encoding, true))\n      )\n    )\n  }\n/**\n * Note this compiler only understand complete buffering, not streaming.\n *\n * @param {Options} [options]\n */\n\nfunction compiler(options = {}) {\n  /** @type {NormalizedExtension} */\n  // @ts-expect-error: our base has all required fields, so the result will too.\n  const config = configure(\n    {\n      transforms: [],\n      canContainEols: [\n        'emphasis',\n        'fragment',\n        'heading',\n        'paragraph',\n        'strong'\n      ],\n      enter: {\n        autolink: opener(link),\n        autolinkProtocol: onenterdata,\n        autolinkEmail: onenterdata,\n        atxHeading: opener(heading),\n        blockQuote: opener(blockQuote),\n        characterEscape: onenterdata,\n        characterReference: onenterdata,\n        codeFenced: opener(codeFlow),\n        codeFencedFenceInfo: buffer,\n        codeFencedFenceMeta: buffer,\n        codeIndented: opener(codeFlow, buffer),\n        codeText: opener(codeText, buffer),\n        codeTextData: onenterdata,\n        data: onenterdata,\n        codeFlowValue: onenterdata,\n        definition: opener(definition),\n        definitionDestinationString: buffer,\n        definitionLabelString: buffer,\n        definitionTitleString: buffer,\n        emphasis: opener(emphasis),\n        hardBreakEscape: opener(hardBreak),\n        hardBreakTrailing: opener(hardBreak),\n        htmlFlow: opener(html, buffer),\n        htmlFlowData: onenterdata,\n        htmlText: opener(html, buffer),\n        htmlTextData: onenterdata,\n        image: opener(image),\n        label: buffer,\n        link: opener(link),\n        listItem: opener(listItem),\n        listItemValue: onenterlistitemvalue,\n        listOrdered: opener(list, onenterlistordered),\n        listUnordered: opener(list),\n        paragraph: opener(paragraph),\n        reference: onenterreference,\n        referenceString: buffer,\n        resourceDestinationString: buffer,\n        resourceTitleString: buffer,\n        setextHeading: opener(heading),\n        strong: opener(strong),\n        thematicBreak: opener(thematicBreak)\n      },\n      exit: {\n        atxHeading: closer(),\n        atxHeadingSequence: onexitatxheadingsequence,\n        autolink: closer(),\n        autolinkEmail: onexitautolinkemail,\n        autolinkProtocol: onexitautolinkprotocol,\n        blockQuote: closer(),\n        characterEscapeValue: onexitdata,\n        characterReferenceMarkerHexadecimal: onexitcharacterreferencemarker,\n        characterReferenceMarkerNumeric: onexitcharacterreferencemarker,\n        characterReferenceValue: onexitcharacterreferencevalue,\n        codeFenced: closer(onexitcodefenced),\n        codeFencedFence: onexitcodefencedfence,\n        codeFencedFenceInfo: onexitcodefencedfenceinfo,\n        codeFencedFenceMeta: onexitcodefencedfencemeta,\n        codeFlowValue: onexitdata,\n        codeIndented: closer(onexitcodeindented),\n        codeText: closer(onexitcodetext),\n        codeTextData: onexitdata,\n        data: onexitdata,\n        definition: closer(),\n        definitionDestinationString: onexitdefinitiondestinationstring,\n        definitionLabelString: onexitdefinitionlabelstring,\n        definitionTitleString: onexitdefinitiontitlestring,\n        emphasis: closer(),\n        hardBreakEscape: closer(onexithardbreak),\n        hardBreakTrailing: closer(onexithardbreak),\n        htmlFlow: closer(onexithtmlflow),\n        htmlFlowData: onexitdata,\n        htmlText: closer(onexithtmltext),\n        htmlTextData: onexitdata,\n        image: closer(onexitimage),\n        label: onexitlabel,\n        labelText: onexitlabeltext,\n        lineEnding: onexitlineending,\n        link: closer(onexitlink),\n        listItem: closer(),\n        listOrdered: closer(),\n        listUnordered: closer(),\n        paragraph: closer(),\n        referenceString: onexitreferencestring,\n        resourceDestinationString: onexitresourcedestinationstring,\n        resourceTitleString: onexitresourcetitlestring,\n        resource: onexitresource,\n        setextHeading: closer(onexitsetextheading),\n        setextHeadingLineSequence: onexitsetextheadinglinesequence,\n        setextHeadingText: onexitsetextheadingtext,\n        strong: closer(),\n        thematicBreak: closer()\n      }\n    },\n    options.mdastExtensions || []\n  )\n  /** @type {CompileData} */\n\n  const data = {}\n  return compile\n  /**\n   * @param {Array.<Event>} events\n   * @returns {Root}\n   */\n\n  function compile(events) {\n    /** @type {Root} */\n    let tree = {\n      type: 'root',\n      children: []\n    }\n    /** @type {CompileContext['stack']} */\n\n    const stack = [tree]\n    /** @type {CompileContext['tokenStack']} */\n\n    const tokenStack = []\n    /** @type {Array.<number>} */\n\n    const listStack = []\n    /** @type {Omit<CompileContext, 'sliceSerialize'>} */\n\n    const context = {\n      stack,\n      tokenStack,\n      config,\n      enter,\n      exit,\n      buffer,\n      resume,\n      setData,\n      getData\n    }\n    let index = -1\n\n    while (++index < events.length) {\n      // We preprocess lists to add `listItem` tokens, and to infer whether\n      // items the list itself are spread out.\n      if (\n        events[index][1].type === 'listOrdered' ||\n        events[index][1].type === 'listUnordered'\n      ) {\n        if (events[index][0] === 'enter') {\n          listStack.push(index)\n        } else {\n          const tail = listStack.pop()\n          index = prepareList(events, tail, index)\n        }\n      }\n    }\n\n    index = -1\n\n    while (++index < events.length) {\n      const handler = config[events[index][0]]\n\n      if (own.call(handler, events[index][1].type)) {\n        handler[events[index][1].type].call(\n          Object.assign(\n            {\n              sliceSerialize: events[index][2].sliceSerialize\n            },\n            context\n          ),\n          events[index][1]\n        )\n      }\n    }\n\n    if (tokenStack.length > 0) {\n      throw new Error(\n        'Cannot close document, a token (`' +\n          tokenStack[tokenStack.length - 1].type +\n          '`, ' +\n          stringifyPosition({\n            start: tokenStack[tokenStack.length - 1].start,\n            end: tokenStack[tokenStack.length - 1].end\n          }) +\n          ') is still open'\n      )\n    } // Figure out `root` position.\n\n    tree.position = {\n      start: point(\n        events.length > 0\n          ? events[0][1].start\n          : {\n              line: 1,\n              column: 1,\n              offset: 0\n            }\n      ),\n      end: point(\n        events.length > 0\n          ? events[events.length - 2][1].end\n          : {\n              line: 1,\n              column: 1,\n              offset: 0\n            }\n      )\n    }\n    index = -1\n\n    while (++index < config.transforms.length) {\n      tree = config.transforms[index](tree) || tree\n    }\n\n    return tree\n  }\n  /**\n   * @param {Array.<Event>} events\n   * @param {number} start\n   * @param {number} length\n   * @returns {number}\n   */\n\n  function prepareList(events, start, length) {\n    let index = start - 1\n    let containerBalance = -1\n    let listSpread = false\n    /** @type {Token|undefined} */\n\n    let listItem\n    /** @type {number|undefined} */\n\n    let lineIndex\n    /** @type {number|undefined} */\n\n    let firstBlankLineIndex\n    /** @type {boolean|undefined} */\n\n    let atMarker\n\n    while (++index <= length) {\n      const event = events[index]\n\n      if (\n        event[1].type === 'listUnordered' ||\n        event[1].type === 'listOrdered' ||\n        event[1].type === 'blockQuote'\n      ) {\n        if (event[0] === 'enter') {\n          containerBalance++\n        } else {\n          containerBalance--\n        }\n\n        atMarker = undefined\n      } else if (event[1].type === 'lineEndingBlank') {\n        if (event[0] === 'enter') {\n          if (\n            listItem &&\n            !atMarker &&\n            !containerBalance &&\n            !firstBlankLineIndex\n          ) {\n            firstBlankLineIndex = index\n          }\n\n          atMarker = undefined\n        }\n      } else if (\n        event[1].type === 'linePrefix' ||\n        event[1].type === 'listItemValue' ||\n        event[1].type === 'listItemMarker' ||\n        event[1].type === 'listItemPrefix' ||\n        event[1].type === 'listItemPrefixWhitespace'\n      ) {\n        // Empty.\n      } else {\n        atMarker = undefined\n      }\n\n      if (\n        (!containerBalance &&\n          event[0] === 'enter' &&\n          event[1].type === 'listItemPrefix') ||\n        (containerBalance === -1 &&\n          event[0] === 'exit' &&\n          (event[1].type === 'listUnordered' ||\n            event[1].type === 'listOrdered'))\n      ) {\n        if (listItem) {\n          let tailIndex = index\n          lineIndex = undefined\n\n          while (tailIndex--) {\n            const tailEvent = events[tailIndex]\n\n            if (\n              tailEvent[1].type === 'lineEnding' ||\n              tailEvent[1].type === 'lineEndingBlank'\n            ) {\n              if (tailEvent[0] === 'exit') continue\n\n              if (lineIndex) {\n                events[lineIndex][1].type = 'lineEndingBlank'\n                listSpread = true\n              }\n\n              tailEvent[1].type = 'lineEnding'\n              lineIndex = tailIndex\n            } else if (\n              tailEvent[1].type === 'linePrefix' ||\n              tailEvent[1].type === 'blockQuotePrefix' ||\n              tailEvent[1].type === 'blockQuotePrefixWhitespace' ||\n              tailEvent[1].type === 'blockQuoteMarker' ||\n              tailEvent[1].type === 'listItemIndent'\n            ) {\n              // Empty\n            } else {\n              break\n            }\n          }\n\n          if (\n            firstBlankLineIndex &&\n            (!lineIndex || firstBlankLineIndex < lineIndex)\n          ) {\n            // @ts-expect-error Patched.\n            listItem._spread = true\n          } // Fix position.\n\n          listItem.end = Object.assign(\n            {},\n            lineIndex ? events[lineIndex][1].start : event[1].end\n          )\n          events.splice(lineIndex || index, 0, ['exit', listItem, event[2]])\n          index++\n          length++\n        } // Create a new list item.\n\n        if (event[1].type === 'listItemPrefix') {\n          listItem = {\n            type: 'listItem',\n            // @ts-expect-error Patched\n            _spread: false,\n            start: Object.assign({}, event[1].start)\n          } // @ts-expect-error: `listItem` is most definitely defined, TS...\n\n          events.splice(index, 0, ['enter', listItem, event[2]])\n          index++\n          length++\n          firstBlankLineIndex = undefined\n          atMarker = true\n        }\n      }\n    } // @ts-expect-error Patched.\n\n    events[start][1]._spread = listSpread\n    return length\n  }\n  /**\n   * @type {CompileContext['setData']}\n   * @param [value]\n   */\n\n  function setData(key, value) {\n    data[key] = value\n  }\n  /**\n   * @type {CompileContext['getData']}\n   * @template {string} K\n   * @param {K} key\n   * @returns {CompileData[K]}\n   */\n\n  function getData(key) {\n    return data[key]\n  }\n  /**\n   * @param {Point} d\n   * @returns {Point}\n   */\n\n  function point(d) {\n    return {\n      line: d.line,\n      column: d.column,\n      offset: d.offset\n    }\n  }\n  /**\n   * @param {(token: Token) => Node} create\n   * @param {Handle} [and]\n   * @returns {Handle}\n   */\n\n  function opener(create, and) {\n    return open\n    /**\n     * @this {CompileContext}\n     * @param {Token} token\n     * @returns {void}\n     */\n\n    function open(token) {\n      enter.call(this, create(token), token)\n      if (and) and.call(this, token)\n    }\n  }\n  /** @type {CompileContext['buffer']} */\n\n  function buffer() {\n    this.stack.push({\n      type: 'fragment',\n      children: []\n    })\n  }\n  /**\n   * @type {CompileContext['enter']}\n   * @template {Node} N\n   * @this {CompileContext}\n   * @param {N} node\n   * @param {Token} token\n   * @returns {N}\n   */\n\n  function enter(node, token) {\n    const parent = this.stack[this.stack.length - 1]\n    // @ts-expect-error: Assume `Node` can exist as a child of `parent`.\n    parent.children.push(node)\n    this.stack.push(node)\n    this.tokenStack.push(token) // @ts-expect-error: `end` will be patched later.\n\n    node.position = {\n      start: point(token.start)\n    }\n    return node\n  }\n  /**\n   * @param {Handle} [and]\n   * @returns {Handle}\n   */\n\n  function closer(and) {\n    return close\n    /**\n     * @this {CompileContext}\n     * @param {Token} token\n     * @returns {void}\n     */\n\n    function close(token) {\n      if (and) and.call(this, token)\n      exit.call(this, token)\n    }\n  }\n  /** @type {CompileContext['exit']} */\n\n  function exit(token) {\n    const node = this.stack.pop()\n    const open = this.tokenStack.pop()\n\n    if (!open) {\n      throw new Error(\n        'Cannot close `' +\n          token.type +\n          '` (' +\n          stringifyPosition({\n            start: token.start,\n            end: token.end\n          }) +\n          '): it’s not open'\n      )\n    } else if (open.type !== token.type) {\n      throw new Error(\n        'Cannot close `' +\n          token.type +\n          '` (' +\n          stringifyPosition({\n            start: token.start,\n            end: token.end\n          }) +\n          '): a different token (`' +\n          open.type +\n          '`, ' +\n          stringifyPosition({\n            start: open.start,\n            end: open.end\n          }) +\n          ') is open'\n      )\n    }\n\n    node.position.end = point(token.end)\n    return node\n  }\n  /**\n   * @this {CompileContext}\n   * @returns {string}\n   */\n\n  function resume() {\n    return toString(this.stack.pop())\n  } //\n  // Handlers.\n  //\n\n  /** @type {Handle} */\n\n  function onenterlistordered() {\n    setData('expectingFirstListItemValue', true)\n  }\n  /** @type {Handle} */\n\n  function onenterlistitemvalue(token) {\n    if (getData('expectingFirstListItemValue')) {\n      const ancestor =\n        /** @type {List} */\n        this.stack[this.stack.length - 2]\n      ancestor.start = Number.parseInt(this.sliceSerialize(token), 10)\n      setData('expectingFirstListItemValue')\n    }\n  }\n  /** @type {Handle} */\n\n  function onexitcodefencedfenceinfo() {\n    const data = this.resume()\n    const node =\n      /** @type {Code} */\n      this.stack[this.stack.length - 1]\n    node.lang = data\n  }\n  /** @type {Handle} */\n\n  function onexitcodefencedfencemeta() {\n    const data = this.resume()\n    const node =\n      /** @type {Code} */\n      this.stack[this.stack.length - 1]\n    node.meta = data\n  }\n  /** @type {Handle} */\n\n  function onexitcodefencedfence() {\n    // Exit if this is the closing fence.\n    if (getData('flowCodeInside')) return\n    this.buffer()\n    setData('flowCodeInside', true)\n  }\n  /** @type {Handle} */\n\n  function onexitcodefenced() {\n    const data = this.resume()\n    const node =\n      /** @type {Code} */\n      this.stack[this.stack.length - 1]\n    node.value = data.replace(/^(\\r?\\n|\\r)|(\\r?\\n|\\r)$/g, '')\n    setData('flowCodeInside')\n  }\n  /** @type {Handle} */\n\n  function onexitcodeindented() {\n    const data = this.resume()\n    const node =\n      /** @type {Code} */\n      this.stack[this.stack.length - 1]\n    node.value = data.replace(/(\\r?\\n|\\r)$/g, '')\n  }\n  /** @type {Handle} */\n\n  function onexitdefinitionlabelstring(token) {\n    // Discard label, use the source content instead.\n    const label = this.resume()\n    const node =\n      /** @type {Definition} */\n      this.stack[this.stack.length - 1]\n    node.label = label\n    node.identifier = normalizeIdentifier(\n      this.sliceSerialize(token)\n    ).toLowerCase()\n  }\n  /** @type {Handle} */\n\n  function onexitdefinitiontitlestring() {\n    const data = this.resume()\n    const node =\n      /** @type {Definition} */\n      this.stack[this.stack.length - 1]\n    node.title = data\n  }\n  /** @type {Handle} */\n\n  function onexitdefinitiondestinationstring() {\n    const data = this.resume()\n    const node =\n      /** @type {Definition} */\n      this.stack[this.stack.length - 1]\n    node.url = data\n  }\n  /** @type {Handle} */\n\n  function onexitatxheadingsequence(token) {\n    const node =\n      /** @type {Heading} */\n      this.stack[this.stack.length - 1]\n\n    if (!node.depth) {\n      const depth = this.sliceSerialize(token).length\n      node.depth = depth\n    }\n  }\n  /** @type {Handle} */\n\n  function onexitsetextheadingtext() {\n    setData('setextHeadingSlurpLineEnding', true)\n  }\n  /** @type {Handle} */\n\n  function onexitsetextheadinglinesequence(token) {\n    const node =\n      /** @type {Heading} */\n      this.stack[this.stack.length - 1]\n    node.depth = this.sliceSerialize(token).charCodeAt(0) === 61 ? 1 : 2\n  }\n  /** @type {Handle} */\n\n  function onexitsetextheading() {\n    setData('setextHeadingSlurpLineEnding')\n  }\n  /** @type {Handle} */\n\n  function onenterdata(token) {\n    const parent =\n      /** @type {Parent} */\n      this.stack[this.stack.length - 1]\n    /** @type {Node} */\n\n    let tail = parent.children[parent.children.length - 1]\n\n    if (!tail || tail.type !== 'text') {\n      // Add a new text node.\n      tail = text() // @ts-expect-error: we’ll add `end` later.\n\n      tail.position = {\n        start: point(token.start)\n      } // @ts-expect-error: Assume `parent` accepts `text`.\n\n      parent.children.push(tail)\n    }\n\n    this.stack.push(tail)\n  }\n  /** @type {Handle} */\n\n  function onexitdata(token) {\n    const tail = this.stack.pop()\n    tail.value += this.sliceSerialize(token)\n    tail.position.end = point(token.end)\n  }\n  /** @type {Handle} */\n\n  function onexitlineending(token) {\n    const context = this.stack[this.stack.length - 1]\n\n    // If we’re at a hard break, include the line ending in there.\n    if (getData('atHardBreak')) {\n      const tail = context.children[context.children.length - 1]\n      tail.position.end = point(token.end)\n      setData('atHardBreak')\n      return\n    }\n\n    if (\n      !getData('setextHeadingSlurpLineEnding') &&\n      config.canContainEols.includes(context.type)\n    ) {\n      onenterdata.call(this, token)\n      onexitdata.call(this, token)\n    }\n  }\n  /** @type {Handle} */\n\n  function onexithardbreak() {\n    setData('atHardBreak', true)\n  }\n  /** @type {Handle} */\n\n  function onexithtmlflow() {\n    const data = this.resume()\n    const node =\n      /** @type {HTML} */\n      this.stack[this.stack.length - 1]\n    node.value = data\n  }\n  /** @type {Handle} */\n\n  function onexithtmltext() {\n    const data = this.resume()\n    const node =\n      /** @type {HTML} */\n      this.stack[this.stack.length - 1]\n    node.value = data\n  }\n  /** @type {Handle} */\n\n  function onexitcodetext() {\n    const data = this.resume()\n    const node =\n      /** @type {InlineCode} */\n      this.stack[this.stack.length - 1]\n    node.value = data\n  }\n  /** @type {Handle} */\n\n  function onexitlink() {\n    const context =\n      /** @type {Link & {identifier: string, label: string}} */\n      this.stack[this.stack.length - 1] // To do: clean.\n\n    if (getData('inReference')) {\n      context.type += 'Reference' // @ts-expect-error: mutate.\n\n      context.referenceType = getData('referenceType') || 'shortcut' // @ts-expect-error: mutate.\n\n      delete context.url\n      delete context.title\n    } else {\n      // @ts-expect-error: mutate.\n      delete context.identifier // @ts-expect-error: mutate.\n\n      delete context.label\n    }\n\n    setData('referenceType')\n  }\n  /** @type {Handle} */\n\n  function onexitimage() {\n    const context =\n      /** @type {Image & {identifier: string, label: string}} */\n      this.stack[this.stack.length - 1] // To do: clean.\n\n    if (getData('inReference')) {\n      context.type += 'Reference' // @ts-expect-error: mutate.\n\n      context.referenceType = getData('referenceType') || 'shortcut' // @ts-expect-error: mutate.\n\n      delete context.url\n      delete context.title\n    } else {\n      // @ts-expect-error: mutate.\n      delete context.identifier // @ts-expect-error: mutate.\n\n      delete context.label\n    }\n\n    setData('referenceType')\n  }\n  /** @type {Handle} */\n\n  function onexitlabeltext(token) {\n    const ancestor =\n      /** @type {(Link|Image) & {identifier: string, label: string}} */\n      this.stack[this.stack.length - 2]\n    const string = this.sliceSerialize(token)\n    ancestor.label = decodeString(string)\n    ancestor.identifier = normalizeIdentifier(string).toLowerCase()\n  }\n  /** @type {Handle} */\n\n  function onexitlabel() {\n    const fragment =\n      /** @type {Fragment} */\n      this.stack[this.stack.length - 1]\n    const value = this.resume()\n    const node =\n      /** @type {(Link|Image) & {identifier: string, label: string}} */\n      this.stack[this.stack.length - 1] // Assume a reference.\n\n    setData('inReference', true)\n\n    if (node.type === 'link') {\n      // @ts-expect-error: Assume static phrasing content.\n      node.children = fragment.children\n    } else {\n      node.alt = value\n    }\n  }\n  /** @type {Handle} */\n\n  function onexitresourcedestinationstring() {\n    const data = this.resume()\n    const node =\n      /** @type {Link|Image} */\n      this.stack[this.stack.length - 1]\n    node.url = data\n  }\n  /** @type {Handle} */\n\n  function onexitresourcetitlestring() {\n    const data = this.resume()\n    const node =\n      /** @type {Link|Image} */\n      this.stack[this.stack.length - 1]\n    node.title = data\n  }\n  /** @type {Handle} */\n\n  function onexitresource() {\n    setData('inReference')\n  }\n  /** @type {Handle} */\n\n  function onenterreference() {\n    setData('referenceType', 'collapsed')\n  }\n  /** @type {Handle} */\n\n  function onexitreferencestring(token) {\n    const label = this.resume()\n    const node =\n      /** @type {LinkReference|ImageReference} */\n      this.stack[this.stack.length - 1]\n    node.label = label\n    node.identifier = normalizeIdentifier(\n      this.sliceSerialize(token)\n    ).toLowerCase()\n    setData('referenceType', 'full')\n  }\n  /** @type {Handle} */\n\n  function onexitcharacterreferencemarker(token) {\n    setData('characterReferenceType', token.type)\n  }\n  /** @type {Handle} */\n\n  function onexitcharacterreferencevalue(token) {\n    const data = this.sliceSerialize(token)\n    const type = getData('characterReferenceType')\n    /** @type {string} */\n\n    let value\n\n    if (type) {\n      value = decodeNumericCharacterReference(\n        data,\n        type === 'characterReferenceMarkerNumeric' ? 10 : 16\n      )\n      setData('characterReferenceType')\n    } else {\n      // @ts-expect-error `decodeEntity` can return false for invalid named\n      // character references, but everything we’ve tokenized is valid.\n      value = decodeEntity(data)\n    }\n\n    const tail = this.stack.pop()\n    tail.value += value\n    tail.position.end = point(token.end)\n  }\n  /** @type {Handle} */\n\n  function onexitautolinkprotocol(token) {\n    onexitdata.call(this, token)\n    const node =\n      /** @type {Link} */\n      this.stack[this.stack.length - 1]\n    node.url = this.sliceSerialize(token)\n  }\n  /** @type {Handle} */\n\n  function onexitautolinkemail(token) {\n    onexitdata.call(this, token)\n    const node =\n      /** @type {Link} */\n      this.stack[this.stack.length - 1]\n    node.url = 'mailto:' + this.sliceSerialize(token)\n  } //\n  // Creaters.\n  //\n\n  /** @returns {Blockquote} */\n\n  function blockQuote() {\n    return {\n      type: 'blockquote',\n      children: []\n    }\n  }\n  /** @returns {Code} */\n\n  function codeFlow() {\n    return {\n      type: 'code',\n      lang: null,\n      meta: null,\n      value: ''\n    }\n  }\n  /** @returns {InlineCode} */\n\n  function codeText() {\n    return {\n      type: 'inlineCode',\n      value: ''\n    }\n  }\n  /** @returns {Definition} */\n\n  function definition() {\n    return {\n      type: 'definition',\n      identifier: '',\n      label: null,\n      title: null,\n      url: ''\n    }\n  }\n  /** @returns {Emphasis} */\n\n  function emphasis() {\n    return {\n      type: 'emphasis',\n      children: []\n    }\n  }\n  /** @returns {Heading} */\n\n  function heading() {\n    // @ts-expect-error `depth` will be set later.\n    return {\n      type: 'heading',\n      depth: undefined,\n      children: []\n    }\n  }\n  /** @returns {Break} */\n\n  function hardBreak() {\n    return {\n      type: 'break'\n    }\n  }\n  /** @returns {HTML} */\n\n  function html() {\n    return {\n      type: 'html',\n      value: ''\n    }\n  }\n  /** @returns {Image} */\n\n  function image() {\n    return {\n      type: 'image',\n      title: null,\n      url: '',\n      alt: null\n    }\n  }\n  /** @returns {Link} */\n\n  function link() {\n    return {\n      type: 'link',\n      title: null,\n      url: '',\n      children: []\n    }\n  }\n  /**\n   * @param {Token} token\n   * @returns {List}\n   */\n\n  function list(token) {\n    return {\n      type: 'list',\n      ordered: token.type === 'listOrdered',\n      start: null,\n      // @ts-expect-error Patched.\n      spread: token._spread,\n      children: []\n    }\n  }\n  /**\n   * @param {Token} token\n   * @returns {ListItem}\n   */\n\n  function listItem(token) {\n    return {\n      type: 'listItem',\n      // @ts-expect-error Patched.\n      spread: token._spread,\n      checked: null,\n      children: []\n    }\n  }\n  /** @returns {Paragraph} */\n\n  function paragraph() {\n    return {\n      type: 'paragraph',\n      children: []\n    }\n  }\n  /** @returns {Strong} */\n\n  function strong() {\n    return {\n      type: 'strong',\n      children: []\n    }\n  }\n  /** @returns {Text} */\n\n  function text() {\n    return {\n      type: 'text',\n      value: ''\n    }\n  }\n  /** @returns {ThematicBreak} */\n\n  function thematicBreak() {\n    return {\n      type: 'thematicBreak'\n    }\n  }\n}\n/**\n * @param {Extension} combined\n * @param {Array.<Extension|Array.<Extension>>} extensions\n * @returns {Extension}\n */\n\nfunction configure(combined, extensions) {\n  let index = -1\n\n  while (++index < extensions.length) {\n    const value = extensions[index]\n\n    if (Array.isArray(value)) {\n      configure(combined, value)\n    } else {\n      extension(combined, value)\n    }\n  }\n\n  return combined\n}\n/**\n * @param {Extension} combined\n * @param {Extension} extension\n * @returns {void}\n */\n\nfunction extension(combined, extension) {\n  /** @type {string} */\n  let key\n\n  for (key in extension) {\n    if (own.call(extension, key)) {\n      const list = key === 'canContainEols' || key === 'transforms'\n      const maybe = own.call(combined, key) ? combined[key] : undefined\n      /* c8 ignore next */\n\n      const left = maybe || (combined[key] = list ? [] : {})\n      const right = extension[key]\n\n      if (right) {\n        if (list) {\n          // @ts-expect-error: `left` is an array.\n          combined[key] = [...left, ...right]\n        } else {\n          Object.assign(left, right)\n        }\n      }\n    }\n  }\n}\n"],"names":["own","hasOwnProperty","configure","combined","extensions","index","length","value","Array","isArray","extension","key","call","list","left","undefined","right","Object","assign","encoding","options","config","transforms","canContainEols","enter","autolink","opener","link","autolinkProtocol","onenterdata","autolinkEmail","atxHeading","heading","blockQuote","characterEscape","characterReference","codeFenced","codeFlow","codeFencedFenceInfo","buffer","codeFencedFenceMeta","codeIndented","codeText","codeTextData","data","codeFlowValue","definition","definitionDestinationString","definitionLabelString","definitionTitleString","emphasis","hardBreakEscape","hardBreak","hardBreakTrailing","htmlFlow","html","htmlFlowData","htmlText","htmlTextData","image","label","listItem","listItemValue","onenterlistitemvalue","listOrdered","onenterlistordered","listUnordered","paragraph","reference","onenterreference","referenceString","resourceDestinationString","resourceTitleString","setextHeading","strong","thematicBreak","exit","closer","atxHeadingSequence","onexitatxheadingsequence","onexitautolinkemail","onexitautolinkprotocol","characterEscapeValue","onexitdata","characterReferenceMarkerHexadecimal","onexitcharacterreferencemarker","characterReferenceMarkerNumeric","characterReferenceValue","onexitcharacterreferencevalue","onexitcodefenced","codeFencedFence","onexitcodefencedfence","onexitcodefencedfenceinfo","onexitcodefencedfencemeta","onexitcodeindented","onexitcodetext","onexitdefinitiondestinationstring","onexitdefinitionlabelstring","onexitdefinitiontitlestring","onexithardbreak","onexithtmlflow","onexithtmltext","onexitimage","onexitlabel","labelText","onexitlabeltext","lineEnding","onexitlineending","onexitlink","onexitreferencestring","onexitresourcedestinationstring","onexitresourcetitlestring","resource","onexitresource","onexitsetextheading","setextHeadingLineSequence","onexitsetextheadinglinesequence","setextHeadingText","onexitsetextheadingtext","mdastExtensions","compile","events","tree","type","children","tokenStack","listStack","context","stack","resume","setData","getData","push","prepareList","pop","handler","sliceSerialize","Error","stringifyPosition","start","end","position","point","line","column","offset","lineIndex","firstBlankLineIndex","atMarker","containerBalance","listSpread","event","tailIndex","tailEvent","_spread","splice","d","create","and","open","token","this","node","close","toString","Number","parseInt","lang","meta","replace","identifier","normalizeIdentifier","toLowerCase","title","url","depth","charCodeAt","parent","tail","text","includes","referenceType","ancestor","string","decodeString","fragment","alt","decodeNumericCharacterReference","decodeEntity","ordered","spread","checked","compiler","postprocess","parse","document","write","preprocess"],"mappings":"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"}