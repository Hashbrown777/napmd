{"version":3,"file":"TreeView.js","sources":["../../../node_modules/@material-ui/lab/es/TreeView/TreeView.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nimport * as React from 'react';\nimport clsx from 'clsx';\nimport PropTypes from 'prop-types';\nimport { withStyles } from '@material-ui/core/styles';\nimport { useControlled } from '@material-ui/core/utils';\nimport TreeViewContext from './TreeViewContext';\nexport const styles = {\n  /* Styles applied to the root element. */\n  root: {\n    padding: 0,\n    margin: 0,\n    listStyle: 'none'\n  }\n};\n\nfunction arrayDiff(arr1, arr2) {\n  if (arr1.length !== arr2.length) return true;\n\n  for (let i = 0; i < arr1.length; i += 1) {\n    if (arr1[i] !== arr2[i]) return true;\n  }\n\n  return false;\n}\n\nconst findNextFirstChar = (firstChars, startIndex, char) => {\n  for (let i = startIndex; i < firstChars.length; i += 1) {\n    if (char === firstChars[i]) {\n      return i;\n    }\n  }\n\n  return -1;\n};\n\nconst defaultExpandedDefault = [];\nconst defaultSelectedDefault = [];\nconst TreeView = /*#__PURE__*/React.forwardRef(function TreeView(props, ref) {\n  const {\n    children,\n    classes,\n    className,\n    defaultCollapseIcon,\n    defaultEndIcon,\n    defaultExpanded = defaultExpandedDefault,\n    defaultExpandIcon,\n    defaultParentIcon,\n    defaultSelected = defaultSelectedDefault,\n    disableSelection = false,\n    multiSelect = false,\n    expanded: expandedProp,\n    onNodeSelect,\n    onNodeToggle,\n    selected: selectedProp\n  } = props,\n        other = _objectWithoutPropertiesLoose(props, [\"children\", \"classes\", \"className\", \"defaultCollapseIcon\", \"defaultEndIcon\", \"defaultExpanded\", \"defaultExpandIcon\", \"defaultParentIcon\", \"defaultSelected\", \"disableSelection\", \"multiSelect\", \"expanded\", \"onNodeSelect\", \"onNodeToggle\", \"selected\"]);\n\n  const [tabbable, setTabbable] = React.useState(null);\n  const [focusedNodeId, setFocusedNodeId] = React.useState(null);\n  const nodeMap = React.useRef({});\n  const firstCharMap = React.useRef({});\n  const visibleNodes = React.useRef([]);\n  const [expanded, setExpandedState] = useControlled({\n    controlled: expandedProp,\n    default: defaultExpanded,\n    name: 'TreeView',\n    state: 'expanded'\n  });\n  const [selected, setSelectedState] = useControlled({\n    controlled: selectedProp,\n    default: defaultSelected,\n    name: 'TreeView',\n    state: 'selected'\n  });\n  /*\r\n   * Status Helpers\r\n   */\n\n  const isExpanded = React.useCallback(id => Array.isArray(expanded) ? expanded.indexOf(id) !== -1 : false, [expanded]);\n  const isSelected = React.useCallback(id => Array.isArray(selected) ? selected.indexOf(id) !== -1 : selected === id, [selected]);\n\n  const isTabbable = id => tabbable === id;\n\n  const isFocused = id => focusedNodeId === id;\n  /*\r\n   * Node Helpers\r\n   */\n\n\n  const getNextNode = id => {\n    const nodeIndex = visibleNodes.current.indexOf(id);\n\n    if (nodeIndex !== -1 && nodeIndex + 1 < visibleNodes.current.length) {\n      return visibleNodes.current[nodeIndex + 1];\n    }\n\n    return null;\n  };\n\n  const getPreviousNode = id => {\n    const nodeIndex = visibleNodes.current.indexOf(id);\n\n    if (nodeIndex !== -1 && nodeIndex - 1 >= 0) {\n      return visibleNodes.current[nodeIndex - 1];\n    }\n\n    return null;\n  };\n\n  const getLastNode = () => visibleNodes.current[visibleNodes.current.length - 1];\n\n  const getFirstNode = () => visibleNodes.current[0];\n\n  const getParent = id => nodeMap.current[id].parent;\n\n  const getNodesInRange = (a, b) => {\n    const aIndex = visibleNodes.current.indexOf(a);\n    const bIndex = visibleNodes.current.indexOf(b);\n    const start = Math.min(aIndex, bIndex);\n    const end = Math.max(aIndex, bIndex);\n    return visibleNodes.current.slice(start, end + 1);\n  };\n  /*\r\n   * Focus Helpers\r\n   */\n\n\n  const focus = id => {\n    if (id) {\n      setTabbable(id);\n      setFocusedNodeId(id);\n    }\n  };\n\n  const focusNextNode = id => focus(getNextNode(id));\n\n  const focusPreviousNode = id => focus(getPreviousNode(id));\n\n  const focusFirstNode = () => focus(getFirstNode());\n\n  const focusLastNode = () => focus(getLastNode());\n\n  const focusByFirstCharacter = (id, char) => {\n    let start;\n    let index;\n    const lowercaseChar = char.toLowerCase();\n    const firstCharIds = [];\n    const firstChars = []; // This really only works since the ids are strings\n\n    Object.keys(firstCharMap.current).forEach(nodeId => {\n      const firstChar = firstCharMap.current[nodeId];\n      const map = nodeMap.current[nodeId];\n      const visible = map.parent ? isExpanded(map.parent) : true;\n\n      if (visible) {\n        firstCharIds.push(nodeId);\n        firstChars.push(firstChar);\n      }\n    }); // Get start index for search based on position of currentItem\n\n    start = firstCharIds.indexOf(id) + 1;\n\n    if (start === nodeMap.current.length) {\n      start = 0;\n    } // Check remaining slots in the menu\n\n\n    index = findNextFirstChar(firstChars, start, lowercaseChar); // If not found in remaining slots, check from beginning\n\n    if (index === -1) {\n      index = findNextFirstChar(firstChars, 0, lowercaseChar);\n    } // If match was found...\n\n\n    if (index > -1) {\n      focus(firstCharIds[index]);\n    }\n  };\n  /*\r\n   * Expansion Helpers\r\n   */\n\n\n  const toggleExpansion = (event, value = focusedNodeId) => {\n    let newExpanded;\n\n    if (expanded.indexOf(value) !== -1) {\n      newExpanded = expanded.filter(id => id !== value);\n      setTabbable(oldTabbable => {\n        const map = nodeMap.current[oldTabbable];\n\n        if (oldTabbable && (map && map.parent ? map.parent.id : null) === value) {\n          return value;\n        }\n\n        return oldTabbable;\n      });\n    } else {\n      newExpanded = [value].concat(expanded);\n    }\n\n    if (onNodeToggle) {\n      onNodeToggle(event, newExpanded);\n    }\n\n    setExpandedState(newExpanded);\n  };\n\n  const expandAllSiblings = (event, id) => {\n    const map = nodeMap.current[id];\n    const parent = nodeMap.current[map.parent];\n    let diff;\n\n    if (parent) {\n      diff = parent.children.filter(child => !isExpanded(child));\n    } else {\n      const topLevelNodes = nodeMap.current[-1].children;\n      diff = topLevelNodes.filter(node => !isExpanded(node));\n    }\n\n    const newExpanded = expanded.concat(diff);\n\n    if (diff.length > 0) {\n      setExpandedState(newExpanded);\n\n      if (onNodeToggle) {\n        onNodeToggle(event, newExpanded);\n      }\n    }\n  };\n  /*\r\n   * Selection Helpers\r\n   */\n\n\n  const lastSelectedNode = React.useRef(null);\n  const lastSelectionWasRange = React.useRef(false);\n  const currentRangeSelection = React.useRef([]);\n\n  const handleRangeArrowSelect = (event, nodes) => {\n    let base = selected;\n    const {\n      start,\n      next,\n      current\n    } = nodes;\n\n    if (!next || !current) {\n      return;\n    }\n\n    if (currentRangeSelection.current.indexOf(current) === -1) {\n      currentRangeSelection.current = [];\n    }\n\n    if (lastSelectionWasRange.current) {\n      if (currentRangeSelection.current.indexOf(next) !== -1) {\n        base = base.filter(id => id === start || id !== current);\n        currentRangeSelection.current = currentRangeSelection.current.filter(id => id === start || id !== current);\n      } else {\n        base.push(next);\n        currentRangeSelection.current.push(next);\n      }\n    } else {\n      base.push(next);\n      currentRangeSelection.current.push(current, next);\n    }\n\n    if (onNodeSelect) {\n      onNodeSelect(event, base);\n    }\n\n    setSelectedState(base);\n  };\n\n  const handleRangeSelect = (event, nodes) => {\n    let base = selected;\n    const {\n      start,\n      end\n    } = nodes; // If last selection was a range selection ignore nodes that were selected.\n\n    if (lastSelectionWasRange.current) {\n      base = selected.filter(id => currentRangeSelection.current.indexOf(id) === -1);\n    }\n\n    const range = getNodesInRange(start, end);\n    currentRangeSelection.current = range;\n    let newSelected = base.concat(range);\n    newSelected = newSelected.filter((id, i) => newSelected.indexOf(id) === i);\n\n    if (onNodeSelect) {\n      onNodeSelect(event, newSelected);\n    }\n\n    setSelectedState(newSelected);\n  };\n\n  const handleMultipleSelect = (event, value) => {\n    let newSelected = [];\n\n    if (selected.indexOf(value) !== -1) {\n      newSelected = selected.filter(id => id !== value);\n    } else {\n      newSelected = [value].concat(selected);\n    }\n\n    if (onNodeSelect) {\n      onNodeSelect(event, newSelected);\n    }\n\n    setSelectedState(newSelected);\n  };\n\n  const handleSingleSelect = (event, value) => {\n    const newSelected = multiSelect ? [value] : value;\n\n    if (onNodeSelect) {\n      onNodeSelect(event, newSelected);\n    }\n\n    setSelectedState(newSelected);\n  };\n\n  const selectNode = (event, id, multiple = false) => {\n    if (id) {\n      if (multiple) {\n        handleMultipleSelect(event, id);\n      } else {\n        handleSingleSelect(event, id);\n      }\n\n      lastSelectedNode.current = id;\n      lastSelectionWasRange.current = false;\n      currentRangeSelection.current = [];\n      return true;\n    }\n\n    return false;\n  };\n\n  const selectRange = (event, nodes, stacked = false) => {\n    const {\n      start = lastSelectedNode.current,\n      end,\n      current\n    } = nodes;\n\n    if (stacked) {\n      handleRangeArrowSelect(event, {\n        start,\n        next: end,\n        current\n      });\n    } else {\n      handleRangeSelect(event, {\n        start,\n        end\n      });\n    }\n\n    lastSelectionWasRange.current = true;\n    return true;\n  };\n\n  const rangeSelectToFirst = (event, id) => {\n    if (!lastSelectedNode.current) {\n      lastSelectedNode.current = id;\n    }\n\n    const start = lastSelectionWasRange.current ? lastSelectedNode.current : id;\n    return selectRange(event, {\n      start,\n      end: getFirstNode()\n    });\n  };\n\n  const rangeSelectToLast = (event, id) => {\n    if (!lastSelectedNode.current) {\n      lastSelectedNode.current = id;\n    }\n\n    const start = lastSelectionWasRange.current ? lastSelectedNode.current : id;\n    return selectRange(event, {\n      start,\n      end: getLastNode()\n    });\n  };\n\n  const selectNextNode = (event, id) => selectRange(event, {\n    end: getNextNode(id),\n    current: id\n  }, true);\n\n  const selectPreviousNode = (event, id) => selectRange(event, {\n    end: getPreviousNode(id),\n    current: id\n  }, true);\n\n  const selectAllNodes = event => selectRange(event, {\n    start: getFirstNode(),\n    end: getLastNode()\n  });\n  /*\r\n   * Mapping Helpers\r\n   */\n\n\n  const addNodeToNodeMap = (id, childrenIds) => {\n    const currentMap = nodeMap.current[id];\n    nodeMap.current[id] = _extends({}, currentMap, {\n      children: childrenIds,\n      id\n    });\n    childrenIds.forEach(childId => {\n      const currentChildMap = nodeMap.current[childId];\n      nodeMap.current[childId] = _extends({}, currentChildMap, {\n        parent: id,\n        id: childId\n      });\n    });\n  };\n\n  const getNodesToRemove = React.useCallback(id => {\n    const map = nodeMap.current[id];\n    const nodes = [];\n\n    if (map) {\n      nodes.push(id);\n\n      if (map.children) {\n        nodes.concat(map.children);\n        map.children.forEach(node => {\n          nodes.concat(getNodesToRemove(node));\n        });\n      }\n    }\n\n    return nodes;\n  }, []);\n  const cleanUpFirstCharMap = React.useCallback(nodes => {\n    const newMap = _extends({}, firstCharMap.current);\n\n    nodes.forEach(node => {\n      if (newMap[node]) {\n        delete newMap[node];\n      }\n    });\n    firstCharMap.current = newMap;\n  }, []);\n  const removeNodeFromNodeMap = React.useCallback(id => {\n    const nodes = getNodesToRemove(id);\n    cleanUpFirstCharMap(nodes);\n\n    const newMap = _extends({}, nodeMap.current);\n\n    nodes.forEach(node => {\n      const map = newMap[node];\n\n      if (map) {\n        if (map.parent) {\n          const parentMap = newMap[map.parent];\n\n          if (parentMap && parentMap.children) {\n            const parentChildren = parentMap.children.filter(c => c !== node);\n            newMap[map.parent] = _extends({}, parentMap, {\n              children: parentChildren\n            });\n          }\n        }\n\n        delete newMap[node];\n      }\n    });\n    nodeMap.current = newMap;\n    setFocusedNodeId(oldFocusedNodeId => {\n      if (oldFocusedNodeId === id) {\n        return null;\n      }\n\n      return oldFocusedNodeId;\n    });\n  }, [getNodesToRemove, cleanUpFirstCharMap]);\n\n  const mapFirstChar = (id, firstChar) => {\n    firstCharMap.current[id] = firstChar;\n  };\n\n  const prevChildIds = React.useRef([]);\n  const [childrenCalculated, setChildrenCalculated] = React.useState(false);\n  React.useEffect(() => {\n    const childIds = [];\n    React.Children.forEach(children, child => {\n      if ( /*#__PURE__*/React.isValidElement(child) && child.props.nodeId) {\n        childIds.push(child.props.nodeId);\n      }\n    });\n\n    if (arrayDiff(prevChildIds.current, childIds)) {\n      nodeMap.current[-1] = {\n        parent: null,\n        children: childIds\n      };\n      childIds.forEach((id, index) => {\n        if (index === 0) {\n          setTabbable(id);\n        }\n      });\n      visibleNodes.current = nodeMap.current[-1].children;\n      prevChildIds.current = childIds;\n      setChildrenCalculated(true);\n    }\n  }, [children]);\n  React.useEffect(() => {\n    const buildVisible = nodes => {\n      let list = [];\n\n      for (let i = 0; i < nodes.length; i += 1) {\n        const item = nodes[i];\n        list.push(item);\n        const childs = nodeMap.current[item].children;\n\n        if (isExpanded(item) && childs) {\n          list = list.concat(buildVisible(childs));\n        }\n      }\n\n      return list;\n    };\n\n    if (childrenCalculated) {\n      visibleNodes.current = buildVisible(nodeMap.current[-1].children);\n    }\n  }, [expanded, childrenCalculated, isExpanded, children]);\n\n  const noopSelection = () => {\n    return false;\n  };\n\n  return /*#__PURE__*/React.createElement(TreeViewContext.Provider, {\n    value: {\n      icons: {\n        defaultCollapseIcon,\n        defaultExpandIcon,\n        defaultParentIcon,\n        defaultEndIcon\n      },\n      focus,\n      focusFirstNode,\n      focusLastNode,\n      focusNextNode,\n      focusPreviousNode,\n      focusByFirstCharacter,\n      expandAllSiblings,\n      toggleExpansion,\n      isExpanded,\n      isFocused,\n      isSelected,\n      selectNode: disableSelection ? noopSelection : selectNode,\n      selectRange: disableSelection ? noopSelection : selectRange,\n      selectNextNode: disableSelection ? noopSelection : selectNextNode,\n      selectPreviousNode: disableSelection ? noopSelection : selectPreviousNode,\n      rangeSelectToFirst: disableSelection ? noopSelection : rangeSelectToFirst,\n      rangeSelectToLast: disableSelection ? noopSelection : rangeSelectToLast,\n      selectAllNodes: disableSelection ? noopSelection : selectAllNodes,\n      isTabbable,\n      multiSelect,\n      getParent,\n      mapFirstChar,\n      addNodeToNodeMap,\n      removeNodeFromNodeMap\n    }\n  }, /*#__PURE__*/React.createElement(\"ul\", _extends({\n    role: \"tree\",\n    \"aria-multiselectable\": multiSelect,\n    className: clsx(classes.root, className),\n    ref: ref\n  }, other), children));\n});\nprocess.env.NODE_ENV !== \"production\" ? TreeView.propTypes = {\n  // ----------------------------- Warning --------------------------------\n  // | These PropTypes are generated from the TypeScript type definitions |\n  // |     To update them edit the d.ts file and run \"yarn proptypes\"     |\n  // ----------------------------------------------------------------------\n\n  /**\r\n   * The content of the component.\r\n   */\n  children: PropTypes.node,\n\n  /**\r\n   * Override or extend the styles applied to the component.\r\n   * See [CSS API](#css) below for more details.\r\n   */\n  classes: PropTypes.object,\n\n  /**\r\n   * @ignore\r\n   */\n  className: PropTypes.string,\n\n  /**\r\n   * The default icon used to collapse the node.\r\n   */\n  defaultCollapseIcon: PropTypes.node,\n\n  /**\r\n   * The default icon displayed next to a end node. This is applied to all\r\n   * tree nodes and can be overridden by the TreeItem `icon` prop.\r\n   */\n  defaultEndIcon: PropTypes.node,\n\n  /**\r\n   * Expanded node ids. (Uncontrolled)\r\n   */\n  defaultExpanded: PropTypes.arrayOf(PropTypes.string),\n\n  /**\r\n   * The default icon used to expand the node.\r\n   */\n  defaultExpandIcon: PropTypes.node,\n\n  /**\r\n   * The default icon displayed next to a parent node. This is applied to all\r\n   * parent nodes and can be overridden by the TreeItem `icon` prop.\r\n   */\n  defaultParentIcon: PropTypes.node,\n\n  /**\r\n   * Selected node ids. (Uncontrolled)\r\n   * When `multiSelect` is true this takes an array of strings; when false (default) a string.\r\n   */\n  defaultSelected: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.string), PropTypes.string]),\n\n  /**\r\n   * If `true` selection is disabled.\r\n   */\n  disableSelection: PropTypes.bool,\n\n  /**\r\n   * Expanded node ids. (Controlled)\r\n   */\n  expanded: PropTypes.arrayOf(PropTypes.string),\n\n  /**\r\n   * If true `ctrl` and `shift` will trigger multiselect.\r\n   */\n  multiSelect: PropTypes.bool,\n\n  /**\r\n   * Callback fired when tree items are selected/unselected.\r\n   *\r\n   * @param {object} event The event source of the callback\r\n   * @param {(array|string)} value of the selected nodes. When `multiSelect` is true\r\n   * this is an array of strings; when false (default) a string.\r\n   */\n  onNodeSelect: PropTypes.func,\n\n  /**\r\n   * Callback fired when tree items are expanded/collapsed.\r\n   *\r\n   * @param {object} event The event source of the callback.\r\n   * @param {array} nodeIds The ids of the expanded nodes.\r\n   */\n  onNodeToggle: PropTypes.func,\n\n  /**\r\n   * Selected node ids. (Controlled)\r\n   * When `multiSelect` is true this takes an array of strings; when false (default) a string.\r\n   */\n  selected: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.string), PropTypes.string])\n} : void 0;\nexport default withStyles(styles, {\n  name: 'MuiTreeView'\n})(TreeView);"],"names":["styles","root","padding","margin","listStyle","findNextFirstChar","firstChars","startIndex","char","i","length","defaultExpandedDefault","defaultSelectedDefault","TreeView","React","forwardRef","props","ref","children","classes","className","defaultCollapseIcon","defaultEndIcon","defaultExpanded","defaultExpandIcon","defaultParentIcon","defaultSelected","disableSelection","multiSelect","expanded","expandedProp","onNodeSelect","onNodeToggle","selected","selectedProp","other","_objectWithoutPropertiesLoose","tabbable","setTabbable","useState","focusedNodeId","setFocusedNodeId","nodeMap","useRef","firstCharMap","visibleNodes","setExpandedState","useControlled","controlled","default","name","state","setSelectedState","isExpanded","useCallback","id","Array","isArray","indexOf","isSelected","getNextNode","nodeIndex","current","getPreviousNode","getLastNode","getFirstNode","focus","lastSelectedNode","lastSelectionWasRange","currentRangeSelection","handleRangeSelect","event","nodes","base","start","end","filter","range","a","b","aIndex","bIndex","Math","min","max","slice","getNodesInRange","newSelected","concat","selectRange","stacked","next","push","handleRangeArrowSelect","getNodesToRemove","map","forEach","node","cleanUpFirstCharMap","newMap","_extends","removeNodeFromNodeMap","parent","parentMap","parentChildren","c","oldFocusedNodeId","prevChildIds","childrenCalculated","setChildrenCalculated","useEffect","childIds","Children","child","isValidElement","nodeId","arr1","arr2","arrayDiff","index","buildVisible","list","item","childs","noopSelection","createElement","TreeViewContext","Provider","value","icons","focusFirstNode","focusLastNode","focusNextNode","focusPreviousNode","focusByFirstCharacter","lowercaseChar","toLowerCase","firstCharIds","Object","keys","firstChar","expandAllSiblings","diff","newExpanded","toggleExpansion","oldTabbable","isFocused","selectNode","multiple","handleMultipleSelect","handleSingleSelect","selectNextNode","selectPreviousNode","rangeSelectToFirst","rangeSelectToLast","selectAllNodes","isTabbable","getParent","mapFirstChar","addNodeToNodeMap","childrenIds","currentMap","childId","currentChildMap","role","clsx","process","env","NODE_ENV","propTypes","PropTypes","object","string","arrayOf","oneOfType","bool","func","withStyles"],"mappings":"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"}