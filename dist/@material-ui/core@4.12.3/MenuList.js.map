{"version":3,"file":"MenuList.js","sources":["../../../node_modules/@material-ui/core/es/MenuList/MenuList.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nimport * as React from 'react';\nimport { isFragment } from 'react-is';\nimport PropTypes from 'prop-types';\nimport * as ReactDOM from 'react-dom';\nimport ownerDocument from '../utils/ownerDocument';\nimport List from '../List';\nimport getScrollbarSize from '../utils/getScrollbarSize';\nimport useForkRef from '../utils/useForkRef';\n\nfunction nextItem(list, item, disableListWrap) {\n  if (list === item) {\n    return list.firstChild;\n  }\n\n  if (item && item.nextElementSibling) {\n    return item.nextElementSibling;\n  }\n\n  return disableListWrap ? null : list.firstChild;\n}\n\nfunction previousItem(list, item, disableListWrap) {\n  if (list === item) {\n    return disableListWrap ? list.firstChild : list.lastChild;\n  }\n\n  if (item && item.previousElementSibling) {\n    return item.previousElementSibling;\n  }\n\n  return disableListWrap ? null : list.lastChild;\n}\n\nfunction textCriteriaMatches(nextFocus, textCriteria) {\n  if (textCriteria === undefined) {\n    return true;\n  }\n\n  let text = nextFocus.innerText;\n\n  if (text === undefined) {\n    // jsdom doesn't support innerText\n    text = nextFocus.textContent;\n  }\n\n  text = text.trim().toLowerCase();\n\n  if (text.length === 0) {\n    return false;\n  }\n\n  if (textCriteria.repeating) {\n    return text[0] === textCriteria.keys[0];\n  }\n\n  return text.indexOf(textCriteria.keys.join('')) === 0;\n}\n\nfunction moveFocus(list, currentFocus, disableListWrap, disabledItemsFocusable, traversalFunction, textCriteria) {\n  let wrappedOnce = false;\n  let nextFocus = traversalFunction(list, currentFocus, currentFocus ? disableListWrap : false);\n\n  while (nextFocus) {\n    // Prevent infinite loop.\n    if (nextFocus === list.firstChild) {\n      if (wrappedOnce) {\n        return;\n      }\n\n      wrappedOnce = true;\n    } // Same logic as useAutocomplete.js\n\n\n    const nextFocusDisabled = disabledItemsFocusable ? false : nextFocus.disabled || nextFocus.getAttribute('aria-disabled') === 'true';\n\n    if (!nextFocus.hasAttribute('tabindex') || !textCriteriaMatches(nextFocus, textCriteria) || nextFocusDisabled) {\n      // Move to the next element.\n      nextFocus = traversalFunction(list, nextFocus, disableListWrap);\n    } else {\n      nextFocus.focus();\n      return;\n    }\n  }\n}\n\nconst useEnhancedEffect = typeof window === 'undefined' ? React.useEffect : React.useLayoutEffect;\n/**\n * A permanently displayed menu following https://www.w3.org/TR/wai-aria-practices/#menubutton.\n * It's exposed to help customization of the [`Menu`](/api/menu/) component. If you\n * use it separately you need to move focus into the component manually. Once\n * the focus is placed inside the component it is fully keyboard accessible.\n */\n\nconst MenuList = /*#__PURE__*/React.forwardRef(function MenuList(props, ref) {\n  const {\n    // private\n    // eslint-disable-next-line react/prop-types\n    actions,\n    autoFocus = false,\n    autoFocusItem = false,\n    children,\n    className,\n    disabledItemsFocusable = false,\n    disableListWrap = false,\n    onKeyDown,\n    variant = 'selectedMenu'\n  } = props,\n        other = _objectWithoutPropertiesLoose(props, [\"actions\", \"autoFocus\", \"autoFocusItem\", \"children\", \"className\", \"disabledItemsFocusable\", \"disableListWrap\", \"onKeyDown\", \"variant\"]);\n\n  const listRef = React.useRef(null);\n  const textCriteriaRef = React.useRef({\n    keys: [],\n    repeating: true,\n    previousKeyMatched: true,\n    lastTime: null\n  });\n  useEnhancedEffect(() => {\n    if (autoFocus) {\n      listRef.current.focus();\n    }\n  }, [autoFocus]);\n  React.useImperativeHandle(actions, () => ({\n    adjustStyleForScrollbar: (containerElement, theme) => {\n      // Let's ignore that piece of logic if users are already overriding the width\n      // of the menu.\n      const noExplicitWidth = !listRef.current.style.width;\n\n      if (containerElement.clientHeight < listRef.current.clientHeight && noExplicitWidth) {\n        const scrollbarSize = `${getScrollbarSize(true)}px`;\n        listRef.current.style[theme.direction === 'rtl' ? 'paddingLeft' : 'paddingRight'] = scrollbarSize;\n        listRef.current.style.width = `calc(100% + ${scrollbarSize})`;\n      }\n\n      return listRef.current;\n    }\n  }), []);\n\n  const handleKeyDown = event => {\n    const list = listRef.current;\n    const key = event.key;\n    /**\n     * @type {Element} - will always be defined since we are in a keydown handler\n     * attached to an element. A keydown event is either dispatched to the activeElement\n     * or document.body or document.documentElement. Only the first case will\n     * trigger this specific handler.\n     */\n\n    const currentFocus = ownerDocument(list).activeElement;\n\n    if (key === 'ArrowDown') {\n      // Prevent scroll of the page\n      event.preventDefault();\n      moveFocus(list, currentFocus, disableListWrap, disabledItemsFocusable, nextItem);\n    } else if (key === 'ArrowUp') {\n      event.preventDefault();\n      moveFocus(list, currentFocus, disableListWrap, disabledItemsFocusable, previousItem);\n    } else if (key === 'Home') {\n      event.preventDefault();\n      moveFocus(list, null, disableListWrap, disabledItemsFocusable, nextItem);\n    } else if (key === 'End') {\n      event.preventDefault();\n      moveFocus(list, null, disableListWrap, disabledItemsFocusable, previousItem);\n    } else if (key.length === 1) {\n      const criteria = textCriteriaRef.current;\n      const lowerKey = key.toLowerCase();\n      const currTime = performance.now();\n\n      if (criteria.keys.length > 0) {\n        // Reset\n        if (currTime - criteria.lastTime > 500) {\n          criteria.keys = [];\n          criteria.repeating = true;\n          criteria.previousKeyMatched = true;\n        } else if (criteria.repeating && lowerKey !== criteria.keys[0]) {\n          criteria.repeating = false;\n        }\n      }\n\n      criteria.lastTime = currTime;\n      criteria.keys.push(lowerKey);\n      const keepFocusOnCurrent = currentFocus && !criteria.repeating && textCriteriaMatches(currentFocus, criteria);\n\n      if (criteria.previousKeyMatched && (keepFocusOnCurrent || moveFocus(list, currentFocus, false, disabledItemsFocusable, nextItem, criteria))) {\n        event.preventDefault();\n      } else {\n        criteria.previousKeyMatched = false;\n      }\n    }\n\n    if (onKeyDown) {\n      onKeyDown(event);\n    }\n  };\n\n  const handleOwnRef = React.useCallback(instance => {\n    // #StrictMode ready\n    listRef.current = ReactDOM.findDOMNode(instance);\n  }, []);\n  const handleRef = useForkRef(handleOwnRef, ref);\n  /**\n   * the index of the item should receive focus\n   * in a `variant=\"selectedMenu\"` it's the first `selected` item\n   * otherwise it's the very first item.\n   */\n\n  let activeItemIndex = -1; // since we inject focus related props into children we have to do a lookahead\n  // to check if there is a `selected` item. We're looking for the last `selected`\n  // item and use the first valid item as a fallback\n\n  React.Children.forEach(children, (child, index) => {\n    if (! /*#__PURE__*/React.isValidElement(child)) {\n      return;\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (isFragment(child)) {\n        console.error([\"Material-UI: The Menu component doesn't accept a Fragment as a child.\", 'Consider providing an array instead.'].join('\\n'));\n      }\n    }\n\n    if (!child.props.disabled) {\n      if (variant === 'selectedMenu' && child.props.selected) {\n        activeItemIndex = index;\n      } else if (activeItemIndex === -1) {\n        activeItemIndex = index;\n      }\n    }\n  });\n  const items = React.Children.map(children, (child, index) => {\n    if (index === activeItemIndex) {\n      const newChildProps = {};\n\n      if (autoFocusItem) {\n        newChildProps.autoFocus = true;\n      }\n\n      if (child.props.tabIndex === undefined && variant === 'selectedMenu') {\n        newChildProps.tabIndex = 0;\n      }\n\n      return /*#__PURE__*/React.cloneElement(child, newChildProps);\n    }\n\n    return child;\n  });\n  return /*#__PURE__*/React.createElement(List, _extends({\n    role: \"menu\",\n    ref: handleRef,\n    className: className,\n    onKeyDown: handleKeyDown,\n    tabIndex: autoFocus ? 0 : -1\n  }, other), items);\n});\nprocess.env.NODE_ENV !== \"production\" ? MenuList.propTypes = {\n  // ----------------------------- Warning --------------------------------\n  // | These PropTypes are generated from the TypeScript type definitions |\n  // |     To update them edit the d.ts file and run \"yarn proptypes\"     |\n  // ----------------------------------------------------------------------\n\n  /**\n   * If `true`, will focus the `[role=\"menu\"]` container and move into tab order.\n   */\n  autoFocus: PropTypes.bool,\n\n  /**\n   * If `true`, will focus the first menuitem if `variant=\"menu\"` or selected item\n   * if `variant=\"selectedMenu\"`.\n   */\n  autoFocusItem: PropTypes.bool,\n\n  /**\n   * MenuList contents, normally `MenuItem`s.\n   */\n  children: PropTypes.node,\n\n  /**\n   * @ignore\n   */\n  className: PropTypes.string,\n\n  /**\n   * If `true`, will allow focus on disabled items.\n   */\n  disabledItemsFocusable: PropTypes.bool,\n\n  /**\n   * If `true`, the menu items will not wrap focus.\n   */\n  disableListWrap: PropTypes.bool,\n\n  /**\n   * @ignore\n   */\n  onKeyDown: PropTypes.func,\n\n  /**\n   * The variant to use. Use `menu` to prevent selected items from impacting the initial focus\n   * and the vertical alignment relative to the anchor element.\n   */\n  variant: PropTypes.oneOf(['menu', 'selectedMenu'])\n} : void 0;\nexport default MenuList;"],"names":["nextItem","list","item","disableListWrap","firstChild","nextElementSibling","previousItem","lastChild","previousElementSibling","textCriteriaMatches","nextFocus","textCriteria","undefined","text","innerText","textContent","trim","toLowerCase","length","repeating","keys","indexOf","join","moveFocus","currentFocus","disabledItemsFocusable","traversalFunction","wrappedOnce","nextFocusDisabled","disabled","getAttribute","hasAttribute","focus","useEnhancedEffect","window","React","useEffect","useLayoutEffect","MenuList","forwardRef","props","ref","actions","autoFocus","autoFocusItem","children","className","onKeyDown","variant","other","_objectWithoutPropertiesLoose","listRef","useRef","textCriteriaRef","previousKeyMatched","lastTime","current","useImperativeHandle","adjustStyleForScrollbar","containerElement","theme","noExplicitWidth","style","width","clientHeight","scrollbarSize","getScrollbarSize","direction","handleOwnRef","useCallback","instance","ReactDOM","findDOMNode","handleRef","useForkRef","activeItemIndex","Children","forEach","child","index","isValidElement","process","env","NODE_ENV","isFragment","console","error","selected","items","map","newChildProps","tabIndex","cloneElement","createElement","List","_extends","role","event","key","ownerDocument","activeElement","preventDefault","criteria","lowerKey","currTime","performance","now","push","keepFocusOnCurrent","propTypes","PropTypes","bool","node","string","func","oneOf"],"mappings":"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"}