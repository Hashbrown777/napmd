{"version":3,"file":"SwipeableDrawer.js","sources":["../../../node_modules/@material-ui/core/es/SwipeableDrawer/SwipeableDrawer.js"],"sourcesContent":["import _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport PropTypes from 'prop-types';\nimport * as ReactDOM from 'react-dom';\nimport { elementTypeAcceptingRef } from '@material-ui/utils';\nimport { getThemeProps } from '@material-ui/styles';\nimport Drawer, { getAnchor, isHorizontal } from '../Drawer/Drawer';\nimport ownerDocument from '../utils/ownerDocument';\nimport useEventCallback from '../utils/useEventCallback';\nimport { duration } from '../styles/transitions';\nimport useTheme from '../styles/useTheme';\nimport { getTransitionProps } from '../transitions/utils';\nimport NoSsr from '../NoSsr';\nimport SwipeArea from './SwipeArea'; // This value is closed to what browsers are using internally to\n// trigger a native scroll.\n\nconst UNCERTAINTY_THRESHOLD = 3; // px\n// We can only have one node at the time claiming ownership for handling the swipe.\n// Otherwise, the UX would be confusing.\n// That's why we use a singleton here.\n\nlet nodeThatClaimedTheSwipe = null; // Exported for test purposes.\n\nexport function reset() {\n  nodeThatClaimedTheSwipe = null;\n}\n\nfunction calculateCurrentX(anchor, touches) {\n  return anchor === 'right' ? document.body.offsetWidth - touches[0].pageX : touches[0].pageX;\n}\n\nfunction calculateCurrentY(anchor, touches) {\n  return anchor === 'bottom' ? window.innerHeight - touches[0].clientY : touches[0].clientY;\n}\n\nfunction getMaxTranslate(horizontalSwipe, paperInstance) {\n  return horizontalSwipe ? paperInstance.clientWidth : paperInstance.clientHeight;\n}\n\nfunction getTranslate(currentTranslate, startLocation, open, maxTranslate) {\n  return Math.min(Math.max(open ? startLocation - currentTranslate : maxTranslate + startLocation - currentTranslate, 0), maxTranslate);\n}\n\nfunction getDomTreeShapes(element, rootNode) {\n  // Adapted from https://github.com/oliviertassinari/react-swipeable-views/blob/7666de1dba253b896911adf2790ce51467670856/packages/react-swipeable-views/src/SwipeableViews.js#L129\n  let domTreeShapes = [];\n\n  while (element && element !== rootNode) {\n    const style = window.getComputedStyle(element);\n\n    if ( // Ignore the scroll children if the element is absolute positioned.\n    style.getPropertyValue('position') === 'absolute' || // Ignore the scroll children if the element has an overflowX hidden\n    style.getPropertyValue('overflow-x') === 'hidden') {\n      domTreeShapes = [];\n    } else if (element.clientWidth > 0 && element.scrollWidth > element.clientWidth || element.clientHeight > 0 && element.scrollHeight > element.clientHeight) {\n      // Ignore the nodes that have no width.\n      // Keep elements with a scroll\n      domTreeShapes.push(element);\n    }\n\n    element = element.parentElement;\n  }\n\n  return domTreeShapes;\n}\n\nfunction findNativeHandler({\n  domTreeShapes,\n  start,\n  current,\n  anchor\n}) {\n  // Adapted from https://github.com/oliviertassinari/react-swipeable-views/blob/7666de1dba253b896911adf2790ce51467670856/packages/react-swipeable-views/src/SwipeableViews.js#L175\n  const axisProperties = {\n    scrollPosition: {\n      x: 'scrollLeft',\n      y: 'scrollTop'\n    },\n    scrollLength: {\n      x: 'scrollWidth',\n      y: 'scrollHeight'\n    },\n    clientLength: {\n      x: 'clientWidth',\n      y: 'clientHeight'\n    }\n  };\n  return domTreeShapes.some(shape => {\n    // Determine if we are going backward or forward.\n    let goingForward = current >= start;\n\n    if (anchor === 'top' || anchor === 'left') {\n      goingForward = !goingForward;\n    }\n\n    const axis = anchor === 'left' || anchor === 'right' ? 'x' : 'y';\n    const scrollPosition = shape[axisProperties.scrollPosition[axis]];\n    const areNotAtStart = scrollPosition > 0;\n    const areNotAtEnd = scrollPosition + shape[axisProperties.clientLength[axis]] < shape[axisProperties.scrollLength[axis]];\n\n    if (goingForward && areNotAtEnd || !goingForward && areNotAtStart) {\n      return shape;\n    }\n\n    return null;\n  });\n}\n\nconst iOS = typeof navigator !== 'undefined' && /iPad|iPhone|iPod/.test(navigator.userAgent);\nconst transitionDurationDefault = {\n  enter: duration.enteringScreen,\n  exit: duration.leavingScreen\n};\nconst useEnhancedEffect = typeof window !== 'undefined' ? React.useLayoutEffect : React.useEffect;\nconst SwipeableDrawer = /*#__PURE__*/React.forwardRef(function SwipeableDrawer(inProps, ref) {\n  const theme = useTheme();\n  const props = getThemeProps({\n    name: 'MuiSwipeableDrawer',\n    props: _extends({}, inProps),\n    theme\n  });\n\n  const {\n    anchor = 'left',\n    disableBackdropTransition = false,\n    disableDiscovery = false,\n    disableSwipeToOpen = iOS,\n    hideBackdrop,\n    hysteresis = 0.52,\n    minFlingVelocity = 450,\n    ModalProps: {\n      BackdropProps\n    } = {},\n    onClose,\n    onOpen,\n    open,\n    PaperProps = {},\n    SwipeAreaProps,\n    swipeAreaWidth = 20,\n    transitionDuration = transitionDurationDefault,\n    variant = 'temporary'\n  } = props,\n        ModalPropsProp = _objectWithoutPropertiesLoose(props.ModalProps, [\"BackdropProps\"]),\n        other = _objectWithoutPropertiesLoose(props, [\"anchor\", \"disableBackdropTransition\", \"disableDiscovery\", \"disableSwipeToOpen\", \"hideBackdrop\", \"hysteresis\", \"minFlingVelocity\", \"ModalProps\", \"onClose\", \"onOpen\", \"open\", \"PaperProps\", \"SwipeAreaProps\", \"swipeAreaWidth\", \"transitionDuration\", \"variant\"]);\n\n  const [maybeSwiping, setMaybeSwiping] = React.useState(false);\n  const swipeInstance = React.useRef({\n    isSwiping: null\n  });\n  const swipeAreaRef = React.useRef();\n  const backdropRef = React.useRef();\n  const paperRef = React.useRef();\n  const touchDetected = React.useRef(false); // Ref for transition duration based on / to match swipe speed\n\n  const calculatedDurationRef = React.useRef(); // Use a ref so the open value used is always up to date inside useCallback.\n\n  useEnhancedEffect(() => {\n    calculatedDurationRef.current = null;\n  }, [open]);\n  const setPosition = React.useCallback((translate, options = {}) => {\n    const {\n      mode = null,\n      changeTransition = true\n    } = options;\n    const anchorRtl = getAnchor(theme, anchor);\n    const rtlTranslateMultiplier = ['right', 'bottom'].indexOf(anchorRtl) !== -1 ? 1 : -1;\n    const horizontalSwipe = isHorizontal(anchor);\n    const transform = horizontalSwipe ? `translate(${rtlTranslateMultiplier * translate}px, 0)` : `translate(0, ${rtlTranslateMultiplier * translate}px)`;\n    const drawerStyle = paperRef.current.style;\n    drawerStyle.webkitTransform = transform;\n    drawerStyle.transform = transform;\n    let transition = '';\n\n    if (mode) {\n      transition = theme.transitions.create('all', getTransitionProps({\n        timeout: transitionDuration\n      }, {\n        mode\n      }));\n    }\n\n    if (changeTransition) {\n      drawerStyle.webkitTransition = transition;\n      drawerStyle.transition = transition;\n    }\n\n    if (!disableBackdropTransition && !hideBackdrop) {\n      const backdropStyle = backdropRef.current.style;\n      backdropStyle.opacity = 1 - translate / getMaxTranslate(horizontalSwipe, paperRef.current);\n\n      if (changeTransition) {\n        backdropStyle.webkitTransition = transition;\n        backdropStyle.transition = transition;\n      }\n    }\n  }, [anchor, disableBackdropTransition, hideBackdrop, theme, transitionDuration]);\n  const handleBodyTouchEnd = useEventCallback(event => {\n    if (!touchDetected.current) {\n      return;\n    }\n\n    nodeThatClaimedTheSwipe = null;\n    touchDetected.current = false;\n    setMaybeSwiping(false); // The swipe wasn't started.\n\n    if (!swipeInstance.current.isSwiping) {\n      swipeInstance.current.isSwiping = null;\n      return;\n    }\n\n    swipeInstance.current.isSwiping = null;\n    const anchorRtl = getAnchor(theme, anchor);\n    const horizontal = isHorizontal(anchor);\n    let current;\n\n    if (horizontal) {\n      current = calculateCurrentX(anchorRtl, event.changedTouches);\n    } else {\n      current = calculateCurrentY(anchorRtl, event.changedTouches);\n    }\n\n    const startLocation = horizontal ? swipeInstance.current.startX : swipeInstance.current.startY;\n    const maxTranslate = getMaxTranslate(horizontal, paperRef.current);\n    const currentTranslate = getTranslate(current, startLocation, open, maxTranslate);\n    const translateRatio = currentTranslate / maxTranslate;\n\n    if (Math.abs(swipeInstance.current.velocity) > minFlingVelocity) {\n      // Calculate transition duration to match swipe speed\n      calculatedDurationRef.current = Math.abs((maxTranslate - currentTranslate) / swipeInstance.current.velocity) * 1000;\n    }\n\n    if (open) {\n      if (swipeInstance.current.velocity > minFlingVelocity || translateRatio > hysteresis) {\n        onClose();\n      } else {\n        // Reset the position, the swipe was aborted.\n        setPosition(0, {\n          mode: 'exit'\n        });\n      }\n\n      return;\n    }\n\n    if (swipeInstance.current.velocity < -minFlingVelocity || 1 - translateRatio > hysteresis) {\n      onOpen();\n    } else {\n      // Reset the position, the swipe was aborted.\n      setPosition(getMaxTranslate(horizontal, paperRef.current), {\n        mode: 'enter'\n      });\n    }\n  });\n  const handleBodyTouchMove = useEventCallback(event => {\n    // the ref may be null when a parent component updates while swiping\n    if (!paperRef.current || !touchDetected.current) {\n      return;\n    } // We are not supposed to handle this touch move because the swipe was started in a scrollable container in the drawer\n\n\n    if (nodeThatClaimedTheSwipe != null && nodeThatClaimedTheSwipe !== swipeInstance.current) {\n      return;\n    }\n\n    const anchorRtl = getAnchor(theme, anchor);\n    const horizontalSwipe = isHorizontal(anchor);\n    const currentX = calculateCurrentX(anchorRtl, event.touches);\n    const currentY = calculateCurrentY(anchorRtl, event.touches);\n\n    if (open && paperRef.current.contains(event.target) && nodeThatClaimedTheSwipe == null) {\n      const domTreeShapes = getDomTreeShapes(event.target, paperRef.current);\n      const nativeHandler = findNativeHandler({\n        domTreeShapes,\n        start: horizontalSwipe ? swipeInstance.current.startX : swipeInstance.current.startY,\n        current: horizontalSwipe ? currentX : currentY,\n        anchor\n      });\n\n      if (nativeHandler) {\n        nodeThatClaimedTheSwipe = nativeHandler;\n        return;\n      }\n\n      nodeThatClaimedTheSwipe = swipeInstance.current;\n    } // We don't know yet.\n\n\n    if (swipeInstance.current.isSwiping == null) {\n      const dx = Math.abs(currentX - swipeInstance.current.startX);\n      const dy = Math.abs(currentY - swipeInstance.current.startY); // We are likely to be swiping, let's prevent the scroll event on iOS.\n\n      if (dx > dy) {\n        if (event.cancelable) {\n          event.preventDefault();\n        }\n      }\n\n      const definitelySwiping = horizontalSwipe ? dx > dy && dx > UNCERTAINTY_THRESHOLD : dy > dx && dy > UNCERTAINTY_THRESHOLD;\n\n      if (definitelySwiping === true || (horizontalSwipe ? dy > UNCERTAINTY_THRESHOLD : dx > UNCERTAINTY_THRESHOLD)) {\n        swipeInstance.current.isSwiping = definitelySwiping;\n\n        if (!definitelySwiping) {\n          handleBodyTouchEnd(event);\n          return;\n        } // Shift the starting point.\n\n\n        swipeInstance.current.startX = currentX;\n        swipeInstance.current.startY = currentY; // Compensate for the part of the drawer displayed on touch start.\n\n        if (!disableDiscovery && !open) {\n          if (horizontalSwipe) {\n            swipeInstance.current.startX -= swipeAreaWidth;\n          } else {\n            swipeInstance.current.startY -= swipeAreaWidth;\n          }\n        }\n      }\n    }\n\n    if (!swipeInstance.current.isSwiping) {\n      return;\n    }\n\n    const maxTranslate = getMaxTranslate(horizontalSwipe, paperRef.current);\n    let startLocation = horizontalSwipe ? swipeInstance.current.startX : swipeInstance.current.startY;\n\n    if (open && !swipeInstance.current.paperHit) {\n      startLocation = Math.min(startLocation, maxTranslate);\n    }\n\n    const translate = getTranslate(horizontalSwipe ? currentX : currentY, startLocation, open, maxTranslate);\n\n    if (open) {\n      if (!swipeInstance.current.paperHit) {\n        const paperHit = horizontalSwipe ? currentX < maxTranslate : currentY < maxTranslate;\n\n        if (paperHit) {\n          swipeInstance.current.paperHit = true;\n          swipeInstance.current.startX = currentX;\n          swipeInstance.current.startY = currentY;\n        } else {\n          return;\n        }\n      } else if (translate === 0) {\n        swipeInstance.current.startX = currentX;\n        swipeInstance.current.startY = currentY;\n      }\n    }\n\n    if (swipeInstance.current.lastTranslate === null) {\n      swipeInstance.current.lastTranslate = translate;\n      swipeInstance.current.lastTime = performance.now() + 1;\n    }\n\n    const velocity = (translate - swipeInstance.current.lastTranslate) / (performance.now() - swipeInstance.current.lastTime) * 1e3; // Low Pass filter.\n\n    swipeInstance.current.velocity = swipeInstance.current.velocity * 0.4 + velocity * 0.6;\n    swipeInstance.current.lastTranslate = translate;\n    swipeInstance.current.lastTime = performance.now(); // We are swiping, let's prevent the scroll event on iOS.\n\n    if (event.cancelable) {\n      event.preventDefault();\n    }\n\n    setPosition(translate);\n  });\n  const handleBodyTouchStart = useEventCallback(event => {\n    // We are not supposed to handle this touch move.\n    // Example of use case: ignore the event if there is a Slider.\n    if (event.defaultPrevented) {\n      return;\n    } // We can only have one node at the time claiming ownership for handling the swipe.\n\n\n    if (event.muiHandled) {\n      return;\n    } // At least one element clogs the drawer interaction zone.\n\n\n    if (open && !backdropRef.current.contains(event.target) && !paperRef.current.contains(event.target)) {\n      return;\n    }\n\n    const anchorRtl = getAnchor(theme, anchor);\n    const horizontalSwipe = isHorizontal(anchor);\n    const currentX = calculateCurrentX(anchorRtl, event.touches);\n    const currentY = calculateCurrentY(anchorRtl, event.touches);\n\n    if (!open) {\n      if (disableSwipeToOpen || event.target !== swipeAreaRef.current) {\n        return;\n      }\n\n      if (horizontalSwipe) {\n        if (currentX > swipeAreaWidth) {\n          return;\n        }\n      } else if (currentY > swipeAreaWidth) {\n        return;\n      }\n    }\n\n    event.muiHandled = true;\n    nodeThatClaimedTheSwipe = null;\n    swipeInstance.current.startX = currentX;\n    swipeInstance.current.startY = currentY;\n    setMaybeSwiping(true);\n\n    if (!open && paperRef.current) {\n      // The ref may be null when a parent component updates while swiping.\n      setPosition(getMaxTranslate(horizontalSwipe, paperRef.current) + (disableDiscovery ? 20 : -swipeAreaWidth), {\n        changeTransition: false\n      });\n    }\n\n    swipeInstance.current.velocity = 0;\n    swipeInstance.current.lastTime = null;\n    swipeInstance.current.lastTranslate = null;\n    swipeInstance.current.paperHit = false;\n    touchDetected.current = true;\n  });\n  React.useEffect(() => {\n    if (variant === 'temporary') {\n      const doc = ownerDocument(paperRef.current);\n      doc.addEventListener('touchstart', handleBodyTouchStart);\n      doc.addEventListener('touchmove', handleBodyTouchMove, {\n        passive: false\n      });\n      doc.addEventListener('touchend', handleBodyTouchEnd);\n      return () => {\n        doc.removeEventListener('touchstart', handleBodyTouchStart);\n        doc.removeEventListener('touchmove', handleBodyTouchMove, {\n          passive: false\n        });\n        doc.removeEventListener('touchend', handleBodyTouchEnd);\n      };\n    }\n\n    return undefined;\n  }, [variant, handleBodyTouchStart, handleBodyTouchMove, handleBodyTouchEnd]);\n  React.useEffect(() => () => {\n    // We need to release the lock.\n    if (nodeThatClaimedTheSwipe === swipeInstance.current) {\n      nodeThatClaimedTheSwipe = null;\n    }\n  }, []);\n  React.useEffect(() => {\n    if (!open) {\n      setMaybeSwiping(false);\n    }\n  }, [open]);\n  const handleBackdropRef = React.useCallback(instance => {\n    // #StrictMode ready\n    backdropRef.current = ReactDOM.findDOMNode(instance);\n  }, []);\n  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(Drawer, _extends({\n    open: variant === 'temporary' && maybeSwiping ? true : open,\n    variant: variant,\n    ModalProps: _extends({\n      BackdropProps: _extends({}, BackdropProps, {\n        ref: handleBackdropRef\n      })\n    }, ModalPropsProp),\n    PaperProps: _extends({}, PaperProps, {\n      style: _extends({\n        pointerEvents: variant === 'temporary' && !open ? 'none' : ''\n      }, PaperProps.style),\n      ref: paperRef\n    }),\n    anchor: anchor,\n    transitionDuration: calculatedDurationRef.current || transitionDuration,\n    onClose: onClose,\n    ref: ref\n  }, other)), !disableSwipeToOpen && variant === 'temporary' && /*#__PURE__*/React.createElement(NoSsr, null, /*#__PURE__*/React.createElement(SwipeArea, _extends({\n    anchor: anchor,\n    ref: swipeAreaRef,\n    width: swipeAreaWidth\n  }, SwipeAreaProps))));\n});\nprocess.env.NODE_ENV !== \"production\" ? SwipeableDrawer.propTypes = {\n  /**\n   * @ignore\n   */\n  anchor: PropTypes.oneOf(['left', 'top', 'right', 'bottom']),\n\n  /**\n   * The content of the component.\n   */\n  children: PropTypes.node,\n\n  /**\n   * Disable the backdrop transition.\n   * This can improve the FPS on low-end devices.\n   */\n  disableBackdropTransition: PropTypes.bool,\n\n  /**\n   * If `true`, touching the screen near the edge of the drawer will not slide in the drawer a bit\n   * to promote accidental discovery of the swipe gesture.\n   */\n  disableDiscovery: PropTypes.bool,\n\n  /**\n   * If `true`, swipe to open is disabled. This is useful in browsers where swiping triggers\n   * navigation actions. Swipe to open is disabled on iOS browsers by default.\n   */\n  disableSwipeToOpen: PropTypes.bool,\n\n  /**\n   * @ignore\n   */\n  hideBackdrop: PropTypes.bool,\n\n  /**\n   * Affects how far the drawer must be opened/closed to change his state.\n   * Specified as percent (0-1) of the width of the drawer\n   */\n  hysteresis: PropTypes.number,\n\n  /**\n   * Defines, from which (average) velocity on, the swipe is\n   * defined as complete although hysteresis isn't reached.\n   * Good threshold is between 250 - 1000 px/s\n   */\n  minFlingVelocity: PropTypes.number,\n\n  /**\n   * @ignore\n   */\n  ModalProps: PropTypes.shape({\n    BackdropProps: PropTypes.shape({\n      component: elementTypeAcceptingRef\n    })\n  }),\n\n  /**\n   * Callback fired when the component requests to be closed.\n   *\n   * @param {object} event The event source of the callback.\n   */\n  onClose: PropTypes.func.isRequired,\n\n  /**\n   * Callback fired when the component requests to be opened.\n   *\n   * @param {object} event The event source of the callback.\n   */\n  onOpen: PropTypes.func.isRequired,\n\n  /**\n   * If `true`, the drawer is open.\n   */\n  open: PropTypes.bool.isRequired,\n\n  /**\n   * @ignore\n   */\n  PaperProps: PropTypes.shape({\n    component: elementTypeAcceptingRef,\n    style: PropTypes.object\n  }),\n\n  /**\n   * The element is used to intercept the touch events on the edge.\n   */\n  SwipeAreaProps: PropTypes.object,\n\n  /**\n   * The width of the left most (or right most) area in pixels where the\n   * drawer can be swiped open from.\n   */\n  swipeAreaWidth: PropTypes.number,\n\n  /**\n   * The duration for the transition, in milliseconds.\n   * You may specify a single timeout for all transitions, or individually with an object.\n   */\n  transitionDuration: PropTypes.oneOfType([PropTypes.number, PropTypes.shape({\n    enter: PropTypes.number,\n    exit: PropTypes.number\n  })]),\n\n  /**\n   * @ignore\n   */\n  variant: PropTypes.oneOf(['permanent', 'persistent', 'temporary'])\n} : void 0;\nexport default SwipeableDrawer;"],"names":["nodeThatClaimedTheSwipe","calculateCurrentX","anchor","touches","document","body","offsetWidth","pageX","calculateCurrentY","window","innerHeight","clientY","getMaxTranslate","horizontalSwipe","paperInstance","clientWidth","clientHeight","getTranslate","currentTranslate","startLocation","open","maxTranslate","Math","min","max","iOS","navigator","test","userAgent","transitionDurationDefault","enter","duration","enteringScreen","exit","leavingScreen","useEnhancedEffect","React","useLayoutEffect","useEffect","SwipeableDrawer","forwardRef","inProps","ref","theme","useTheme","props","getThemeProps","name","_extends","disableBackdropTransition","disableDiscovery","disableSwipeToOpen","hideBackdrop","hysteresis","minFlingVelocity","ModalProps","BackdropProps","onClose","onOpen","PaperProps","SwipeAreaProps","swipeAreaWidth","transitionDuration","variant","ModalPropsProp","_objectWithoutPropertiesLoose","other","maybeSwiping","setMaybeSwiping","useState","swipeInstance","useRef","isSwiping","swipeAreaRef","backdropRef","paperRef","touchDetected","calculatedDurationRef","current","setPosition","useCallback","translate","options","mode","changeTransition","anchorRtl","getAnchor","rtlTranslateMultiplier","indexOf","isHorizontal","transform","drawerStyle","style","webkitTransform","transition","transitions","create","getTransitionProps","timeout","webkitTransition","backdropStyle","opacity","handleBodyTouchEnd","useEventCallback","event","horizontal","changedTouches","startX","startY","translateRatio","abs","velocity","handleBodyTouchMove","currentX","currentY","contains","target","nativeHandler","domTreeShapes","start","axisProperties","x","y","some","shape","goingForward","axis","scrollPosition","areNotAtStart","areNotAtEnd","findNativeHandler","element","rootNode","getComputedStyle","getPropertyValue","scrollWidth","scrollHeight","push","parentElement","getDomTreeShapes","dx","dy","cancelable","preventDefault","definitelySwiping","paperHit","lastTranslate","lastTime","performance","now","handleBodyTouchStart","defaultPrevented","muiHandled","doc","ownerDocument","addEventListener","passive","removeEventListener","handleBackdropRef","instance","ReactDOM","findDOMNode","createElement","Fragment","Drawer","pointerEvents","NoSsr","SwipeArea","width","process","env","NODE_ENV","propTypes","PropTypes","oneOf","children","node","bool","number","component","elementTypeAcceptingRef","func","isRequired","object","oneOfType"],"mappings":"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"}