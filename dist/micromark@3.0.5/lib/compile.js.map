{"version":3,"file":"compile.js","sources":["../../../node_modules/micromark/lib/compile.js"],"sourcesContent":["/**\n * While micromark is a lexer/tokenizer, the common case of going from markdown\n * to html is currently built in as this module, even though the parts can be\n * used separately to build ASTs, CSTs, or many other output formats.\n *\n * Having an HTML compiler built in is useful because it allows us to check for\n * compliancy to CommonMark, the de facto norm of markdown, specified in roughly\n * 600 input/output cases.\n *\n * This module has an interface that accepts lists of events instead of the\n * whole at once, however, because markdown can’t be truly streaming, we buffer\n * events before processing and outputting the final result.\n */\n\n/**\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').CompileOptions} CompileOptions\n * @typedef {import('micromark-util-types').CompileData} CompileData\n * @typedef {import('micromark-util-types').CompileContext} CompileContext\n * @typedef {import('micromark-util-types').Compile} Compile\n * @typedef {import('micromark-util-types').Handle} Handle\n * @typedef {import('micromark-util-types').HtmlExtension} HtmlExtension\n * @typedef {import('micromark-util-types').NormalizedHtmlExtension} NormalizedHtmlExtension\n */\n\n/**\n * @typedef Media\n * @property {boolean} [image]\n * @property {string} [labelId]\n * @property {string} [label]\n * @property {string} [referenceId]\n * @property {string} [destination]\n * @property {string} [title]\n *\n * @typedef Definition\n * @property {string} [destination]\n * @property {string} [title]\n */\nimport {decodeEntity} from 'parse-entities/decode-entity.js'\nimport {combineHtmlExtensions} from 'micromark-util-combine-extensions'\nimport {push} from 'micromark-util-chunked'\nimport {decodeNumericCharacterReference} from 'micromark-util-decode-numeric-character-reference'\nimport {encode as _encode} from 'micromark-util-encode'\nimport {normalizeIdentifier} from 'micromark-util-normalize-identifier'\nimport {sanitizeUri} from 'micromark-util-sanitize-uri'\nconst hasOwnProperty = {}.hasOwnProperty\n/**\n * These two are allowlists of safe protocols for full URLs in respectively the\n * `href` (on `<a>`) and `src` (on `<img>`) attributes.\n * They are based on what is allowed on GitHub,\n * <https://github.com/syntax-tree/hast-util-sanitize/blob/9275b21/lib/github.json#L31>\n */\n\nconst protocolHref = /^(https?|ircs?|mailto|xmpp)$/i\nconst protocolSrc = /^https?$/i\n/**\n * @param {CompileOptions} [options]\n * @returns {Compile}\n */\n\nexport function compile(options = {}) {\n  /**\n   * Tags is needed because according to markdown, links and emphasis and\n   * whatnot can exist in images, however, as HTML doesn’t allow content in\n   * images, the tags are ignored in the `alt` attribute, but the content\n   * remains.\n   *\n   * @type {boolean|undefined}\n   */\n  let tags = true\n  /**\n   * An object to track identifiers to media (URLs and titles) defined with\n   * definitions.\n   *\n   * @type {Record<string, Definition>}\n   */\n\n  const definitions = {}\n  /**\n   * A lot of the handlers need to capture some of the output data, modify it\n   * somehow, and then deal with it.\n   * We do that by tracking a stack of buffers, that can be opened (with\n   * `buffer`) and closed (with `resume`) to access them.\n   *\n   * @type {string[][]}\n   */\n\n  const buffers = [[]]\n  /**\n   * As we can have links in images and the other way around, where the deepest\n   * ones are closed first, we need to track which one we’re in.\n   *\n   * @type {Media[]}\n   */\n\n  const mediaStack = []\n  /**\n   * Same as `mediaStack` for tightness, which is specific to lists.\n   * We need to track if we’re currently in a tight or loose container.\n   *\n   * @type {boolean[]}\n   */\n\n  const tightStack = []\n  /** @type {HtmlExtension} */\n\n  const defaultHandlers = {\n    enter: {\n      blockQuote: onenterblockquote,\n      codeFenced: onentercodefenced,\n      codeFencedFenceInfo: buffer,\n      codeFencedFenceMeta: buffer,\n      codeIndented: onentercodeindented,\n      codeText: onentercodetext,\n      content: onentercontent,\n      definition: onenterdefinition,\n      definitionDestinationString: onenterdefinitiondestinationstring,\n      definitionLabelString: buffer,\n      definitionTitleString: buffer,\n      emphasis: onenteremphasis,\n      htmlFlow: onenterhtmlflow,\n      htmlText: onenterhtml,\n      image: onenterimage,\n      label: buffer,\n      link: onenterlink,\n      listItemMarker: onenterlistitemmarker,\n      listItemValue: onenterlistitemvalue,\n      listOrdered: onenterlistordered,\n      listUnordered: onenterlistunordered,\n      paragraph: onenterparagraph,\n      reference: buffer,\n      resource: onenterresource,\n      resourceDestinationString: onenterresourcedestinationstring,\n      resourceTitleString: buffer,\n      setextHeading: onentersetextheading,\n      strong: onenterstrong\n    },\n    exit: {\n      atxHeading: onexitatxheading,\n      atxHeadingSequence: onexitatxheadingsequence,\n      autolinkEmail: onexitautolinkemail,\n      autolinkProtocol: onexitautolinkprotocol,\n      blockQuote: onexitblockquote,\n      characterEscapeValue: onexitdata,\n      characterReferenceMarkerHexadecimal: onexitcharacterreferencemarker,\n      characterReferenceMarkerNumeric: onexitcharacterreferencemarker,\n      characterReferenceValue: onexitcharacterreferencevalue,\n      codeFenced: onexitflowcode,\n      codeFencedFence: onexitcodefencedfence,\n      codeFencedFenceInfo: onexitcodefencedfenceinfo,\n      codeFencedFenceMeta: resume,\n      codeFlowValue: onexitcodeflowvalue,\n      codeIndented: onexitflowcode,\n      codeText: onexitcodetext,\n      codeTextData: onexitdata,\n      data: onexitdata,\n      definition: onexitdefinition,\n      definitionDestinationString: onexitdefinitiondestinationstring,\n      definitionLabelString: onexitdefinitionlabelstring,\n      definitionTitleString: onexitdefinitiontitlestring,\n      emphasis: onexitemphasis,\n      hardBreakEscape: onexithardbreak,\n      hardBreakTrailing: onexithardbreak,\n      htmlFlow: onexithtml,\n      htmlFlowData: onexitdata,\n      htmlText: onexithtml,\n      htmlTextData: onexitdata,\n      image: onexitmedia,\n      label: onexitlabel,\n      labelText: onexitlabeltext,\n      lineEnding: onexitlineending,\n      link: onexitmedia,\n      listOrdered: onexitlistordered,\n      listUnordered: onexitlistunordered,\n      paragraph: onexitparagraph,\n      reference: resume,\n      referenceString: onexitreferencestring,\n      resource: resume,\n      resourceDestinationString: onexitresourcedestinationstring,\n      resourceTitleString: onexitresourcetitlestring,\n      setextHeading: onexitsetextheading,\n      setextHeadingLineSequence: onexitsetextheadinglinesequence,\n      setextHeadingText: onexitsetextheadingtext,\n      strong: onexitstrong,\n      thematicBreak: onexitthematicbreak\n    }\n  }\n  /**\n   * Combine the HTML extensions with the default handlers.\n   * An HTML extension is an object whose fields are either `enter` or `exit`\n   * (reflecting whether a token is entered or exited).\n   * The values at such objects are names of tokens mapping to handlers.\n   * Handlers are called, respectively when a token is opener or closed, with\n   * that token, and a context as `this`.\n   *\n   * @type {NormalizedHtmlExtension}\n   */\n  // @ts-expect-error `defaultHandlers` is full, so the result will be too.\n\n  const handlers = combineHtmlExtensions(\n    [defaultHandlers].concat(options.htmlExtensions || [])\n  )\n  /**\n   * Handlers do often need to keep track of some state.\n   * That state is provided here as a key-value store (an object).\n   *\n   * @type {CompileData}\n   */\n\n  const data = {\n    tightStack\n  }\n  /**\n   * The context for handlers references a couple of useful functions.\n   * In handlers from extensions, those can be accessed at `this`.\n   * For the handlers here, they can be accessed directly.\n   *\n   * @type {Omit<CompileContext, 'sliceSerialize'>}\n   */\n\n  const context = {\n    lineEndingIfNeeded,\n    options,\n    encode,\n    raw,\n    tag,\n    buffer,\n    resume,\n    setData,\n    getData\n  }\n  /**\n   * Generally, micromark copies line endings (`'\\r'`, `'\\n'`, `'\\r\\n'`) in the\n   * markdown document over to the compiled HTML.\n   * In some cases, such as `> a`, CommonMark requires that extra line endings\n   * are added: `<blockquote>\\n<p>a</p>\\n</blockquote>`.\n   * This variable hold the default line ending when given (or `undefined`),\n   * and in the latter case will be updated to the first found line ending if\n   * there is one.\n   */\n\n  let lineEndingStyle = options.defaultLineEnding // Return the function that handles a slice of events.\n\n  return compile\n  /**\n   * Deal w/ a slice of events.\n   * Return either the empty string if there’s nothing of note to return, or the\n   * result when done.\n   *\n   * @param {Event[]} events\n   * @returns {string}\n   */\n\n  function compile(events) {\n    let index = -1\n    let start = 0\n    /** @type {number[]} */\n\n    const listStack = [] // As definitions can come after references, we need to figure out the media\n    // (urls and titles) defined by them before handling the references.\n    // So, we do sort of what HTML does: put metadata at the start (in head), and\n    // then put content after (`body`).\n\n    /** @type {Event[]} */\n\n    let head = []\n    /** @type {Event[]} */\n\n    let body = []\n\n    while (++index < events.length) {\n      // Figure out the line ending style used in the document.\n      if (\n        !lineEndingStyle &&\n        (events[index][1].type === 'lineEnding' ||\n          events[index][1].type === 'lineEndingBlank')\n      ) {\n        // @ts-expect-error Hush, it’s a line ending.\n        lineEndingStyle = events[index][2].sliceSerialize(events[index][1])\n      } // Preprocess lists to infer whether the list is loose or not.\n\n      if (\n        events[index][1].type === 'listOrdered' ||\n        events[index][1].type === 'listUnordered'\n      ) {\n        if (events[index][0] === 'enter') {\n          listStack.push(index)\n        } else {\n          prepareList(events.slice(listStack.pop(), index))\n        }\n      } // Move definitions to the front.\n\n      if (events[index][1].type === 'definition') {\n        if (events[index][0] === 'enter') {\n          body = push(body, events.slice(start, index))\n          start = index\n        } else {\n          head = push(head, events.slice(start, index + 1))\n          start = index + 1\n        }\n      }\n    }\n\n    head = push(head, body)\n    head = push(head, events.slice(start))\n    index = -1\n    const result = head // Handle the start of the document, if defined.\n\n    if (handlers.enter.null) {\n      handlers.enter.null.call(context)\n    } // Handle all events.\n\n    while (++index < events.length) {\n      const handler = handlers[result[index][0]]\n\n      if (hasOwnProperty.call(handler, result[index][1].type)) {\n        handler[result[index][1].type].call(\n          Object.assign(\n            {\n              sliceSerialize: result[index][2].sliceSerialize\n            },\n            context\n          ),\n          result[index][1]\n        )\n      }\n    } // Handle the end of the document, if defined.\n\n    if (handlers.exit.null) {\n      handlers.exit.null.call(context)\n    }\n\n    return buffers[0].join('')\n  }\n  /**\n   * Figure out whether lists are loose or not.\n   *\n   * @param {Event[]} slice\n   * @returns {void}\n   */\n\n  function prepareList(slice) {\n    const length = slice.length\n    let index = 0 // Skip open.\n\n    let containerBalance = 0\n    let loose = false\n    /** @type {boolean|undefined} */\n\n    let atMarker\n\n    while (++index < length) {\n      const event = slice[index]\n\n      if (event[1]._container) {\n        atMarker = undefined\n\n        if (event[0] === 'enter') {\n          containerBalance++\n        } else {\n          containerBalance--\n        }\n      } else\n        switch (event[1].type) {\n          case 'listItemPrefix': {\n            if (event[0] === 'exit') {\n              atMarker = true\n            }\n\n            break\n          }\n\n          case 'linePrefix': {\n            // Ignore\n            break\n          }\n\n          case 'lineEndingBlank': {\n            if (event[0] === 'enter' && !containerBalance) {\n              if (atMarker) {\n                atMarker = undefined\n              } else {\n                loose = true\n              }\n            }\n\n            break\n          }\n\n          default: {\n            atMarker = undefined\n          }\n        }\n    }\n\n    slice[0][1]._loose = loose\n  }\n  /**\n   * @type {CompileContext['setData']}\n   * @param [value]\n   */\n\n  function setData(key, value) {\n    data[key] = value\n  }\n  /**\n   * @type {CompileContext['getData']}\n   * @template {string} K\n   * @param {K} key\n   * @returns {CompileData[K]}\n   */\n\n  function getData(key) {\n    return data[key]\n  }\n  /** @type {CompileContext['buffer']} */\n\n  function buffer() {\n    buffers.push([])\n  }\n  /** @type {CompileContext['resume']} */\n\n  function resume() {\n    const buf = buffers.pop()\n    return buf.join('')\n  }\n  /** @type {CompileContext['tag']} */\n\n  function tag(value) {\n    if (!tags) return\n    setData('lastWasTag', true)\n    buffers[buffers.length - 1].push(value)\n  }\n  /** @type {CompileContext['raw']} */\n\n  function raw(value) {\n    setData('lastWasTag')\n    buffers[buffers.length - 1].push(value)\n  }\n  /**\n   * Output an extra line ending.\n   *\n   * @returns {void}\n   */\n\n  function lineEnding() {\n    raw(lineEndingStyle || '\\n')\n  }\n  /** @type {CompileContext['lineEndingIfNeeded']} */\n\n  function lineEndingIfNeeded() {\n    const buffer = buffers[buffers.length - 1]\n    const slice = buffer[buffer.length - 1]\n    const previous = slice ? slice.charCodeAt(slice.length - 1) : null\n\n    if (previous === 10 || previous === 13 || previous === null) {\n      return\n    }\n\n    lineEnding()\n  }\n  /** @type {CompileContext['encode']} */\n\n  function encode(value) {\n    return getData('ignoreEncode') ? value : _encode(value)\n  } //\n  // Handlers.\n  //\n\n  /** @type {Handle} */\n\n  function onenterlistordered(token) {\n    tightStack.push(!token._loose)\n    lineEndingIfNeeded()\n    tag('<ol')\n    setData('expectFirstItem', true)\n  }\n  /** @type {Handle} */\n\n  function onenterlistunordered(token) {\n    tightStack.push(!token._loose)\n    lineEndingIfNeeded()\n    tag('<ul')\n    setData('expectFirstItem', true)\n  }\n  /** @type {Handle} */\n\n  function onenterlistitemvalue(token) {\n    if (getData('expectFirstItem')) {\n      const value = Number.parseInt(this.sliceSerialize(token), 10)\n\n      if (value !== 1) {\n        tag(' start=\"' + encode(String(value)) + '\"')\n      }\n    }\n  }\n  /** @type {Handle} */\n\n  function onenterlistitemmarker() {\n    if (getData('expectFirstItem')) {\n      tag('>')\n    } else {\n      onexitlistitem()\n    }\n\n    lineEndingIfNeeded()\n    tag('<li>')\n    setData('expectFirstItem') // “Hack” to prevent a line ending from showing up if the item is empty.\n\n    setData('lastWasTag')\n  }\n  /** @type {Handle} */\n\n  function onexitlistordered() {\n    onexitlistitem()\n    tightStack.pop()\n    lineEnding()\n    tag('</ol>')\n  }\n  /** @type {Handle} */\n\n  function onexitlistunordered() {\n    onexitlistitem()\n    tightStack.pop()\n    lineEnding()\n    tag('</ul>')\n  }\n  /** @type {Handle} */\n\n  function onexitlistitem() {\n    if (getData('lastWasTag') && !getData('slurpAllLineEndings')) {\n      lineEndingIfNeeded()\n    }\n\n    tag('</li>')\n    setData('slurpAllLineEndings')\n  }\n  /** @type {Handle} */\n\n  function onenterblockquote() {\n    tightStack.push(false)\n    lineEndingIfNeeded()\n    tag('<blockquote>')\n  }\n  /** @type {Handle} */\n\n  function onexitblockquote() {\n    tightStack.pop()\n    lineEndingIfNeeded()\n    tag('</blockquote>')\n    setData('slurpAllLineEndings')\n  }\n  /** @type {Handle} */\n\n  function onenterparagraph() {\n    if (!tightStack[tightStack.length - 1]) {\n      lineEndingIfNeeded()\n      tag('<p>')\n    }\n\n    setData('slurpAllLineEndings')\n  }\n  /** @type {Handle} */\n\n  function onexitparagraph() {\n    if (tightStack[tightStack.length - 1]) {\n      setData('slurpAllLineEndings', true)\n    } else {\n      tag('</p>')\n    }\n  }\n  /** @type {Handle} */\n\n  function onentercodefenced() {\n    lineEndingIfNeeded()\n    tag('<pre><code')\n    setData('fencesCount', 0)\n  }\n  /** @type {Handle} */\n\n  function onexitcodefencedfenceinfo() {\n    const value = resume()\n    tag(' class=\"language-' + value + '\"')\n  }\n  /** @type {Handle} */\n\n  function onexitcodefencedfence() {\n    const count = getData('fencesCount') || 0\n\n    if (!count) {\n      tag('>')\n      setData('slurpOneLineEnding', true)\n    }\n\n    setData('fencesCount', count + 1)\n  }\n  /** @type {Handle} */\n\n  function onentercodeindented() {\n    lineEndingIfNeeded()\n    tag('<pre><code>')\n  }\n  /** @type {Handle} */\n\n  function onexitflowcode() {\n    const count = getData('fencesCount') // One special case is if we are inside a container, and the fenced code was\n    // not closed (meaning it runs to the end).\n    // In that case, the following line ending, is considered *outside* the\n    // fenced code and block quote by micromark, but CM wants to treat that\n    // ending as part of the code.\n\n    if (\n      count !== undefined &&\n      count < 2 && // @ts-expect-error `tightStack` is always set.\n      data.tightStack.length > 0 &&\n      !getData('lastWasTag')\n    ) {\n      lineEnding()\n    } // But in most cases, it’s simpler: when we’ve seen some data, emit an extra\n    // line ending when needed.\n\n    if (getData('flowCodeSeenData')) {\n      lineEndingIfNeeded()\n    }\n\n    tag('</code></pre>')\n    if (count !== undefined && count < 2) lineEndingIfNeeded()\n    setData('flowCodeSeenData')\n    setData('fencesCount')\n    setData('slurpOneLineEnding')\n  }\n  /** @type {Handle} */\n\n  function onenterimage() {\n    mediaStack.push({\n      image: true\n    })\n    tags = undefined // Disallow tags.\n  }\n  /** @type {Handle} */\n\n  function onenterlink() {\n    mediaStack.push({})\n  }\n  /** @type {Handle} */\n\n  function onexitlabeltext(token) {\n    mediaStack[mediaStack.length - 1].labelId = this.sliceSerialize(token)\n  }\n  /** @type {Handle} */\n\n  function onexitlabel() {\n    mediaStack[mediaStack.length - 1].label = resume()\n  }\n  /** @type {Handle} */\n\n  function onexitreferencestring(token) {\n    mediaStack[mediaStack.length - 1].referenceId = this.sliceSerialize(token)\n  }\n  /** @type {Handle} */\n\n  function onenterresource() {\n    buffer() // We can have line endings in the resource, ignore them.\n\n    mediaStack[mediaStack.length - 1].destination = ''\n  }\n  /** @type {Handle} */\n\n  function onenterresourcedestinationstring() {\n    buffer() // Ignore encoding the result, as we’ll first percent encode the url and\n    // encode manually after.\n\n    setData('ignoreEncode', true)\n  }\n  /** @type {Handle} */\n\n  function onexitresourcedestinationstring() {\n    mediaStack[mediaStack.length - 1].destination = resume()\n    setData('ignoreEncode')\n  }\n  /** @type {Handle} */\n\n  function onexitresourcetitlestring() {\n    mediaStack[mediaStack.length - 1].title = resume()\n  }\n  /** @type {Handle} */\n\n  function onexitmedia() {\n    let index = mediaStack.length - 1 // Skip current.\n\n    const media = mediaStack[index]\n    const id = media.referenceId || media.labelId\n    const context =\n      media.destination === undefined\n        ? definitions[normalizeIdentifier(id)]\n        : media\n    tags = true\n\n    while (index--) {\n      if (mediaStack[index].image) {\n        tags = undefined\n        break\n      }\n    }\n\n    if (media.image) {\n      tag(\n        '<img src=\"' +\n          sanitizeUri(\n            context.destination,\n            options.allowDangerousProtocol ? undefined : protocolSrc\n          ) +\n          '\" alt=\"'\n      )\n      raw(media.label)\n      tag('\"')\n    } else {\n      tag(\n        '<a href=\"' +\n          sanitizeUri(\n            context.destination,\n            options.allowDangerousProtocol ? undefined : protocolHref\n          ) +\n          '\"'\n      )\n    }\n\n    tag(context.title ? ' title=\"' + context.title + '\"' : '')\n\n    if (media.image) {\n      tag(' />')\n    } else {\n      tag('>')\n      raw(media.label)\n      tag('</a>')\n    }\n\n    mediaStack.pop()\n  }\n  /** @type {Handle} */\n\n  function onenterdefinition() {\n    buffer()\n    mediaStack.push({})\n  }\n  /** @type {Handle} */\n\n  function onexitdefinitionlabelstring(token) {\n    // Discard label, use the source content instead.\n    resume()\n    mediaStack[mediaStack.length - 1].labelId = this.sliceSerialize(token)\n  }\n  /** @type {Handle} */\n\n  function onenterdefinitiondestinationstring() {\n    buffer()\n    setData('ignoreEncode', true)\n  }\n  /** @type {Handle} */\n\n  function onexitdefinitiondestinationstring() {\n    mediaStack[mediaStack.length - 1].destination = resume()\n    setData('ignoreEncode')\n  }\n  /** @type {Handle} */\n\n  function onexitdefinitiontitlestring() {\n    mediaStack[mediaStack.length - 1].title = resume()\n  }\n  /** @type {Handle} */\n\n  function onexitdefinition() {\n    const media = mediaStack[mediaStack.length - 1]\n    const id = normalizeIdentifier(media.labelId)\n    resume()\n\n    if (!hasOwnProperty.call(definitions, id)) {\n      definitions[id] = mediaStack[mediaStack.length - 1]\n    }\n\n    mediaStack.pop()\n  }\n  /** @type {Handle} */\n\n  function onentercontent() {\n    setData('slurpAllLineEndings', true)\n  }\n  /** @type {Handle} */\n\n  function onexitatxheadingsequence(token) {\n    // Exit for further sequences.\n    if (getData('headingRank')) return\n    setData('headingRank', this.sliceSerialize(token).length)\n    lineEndingIfNeeded()\n    tag('<h' + getData('headingRank') + '>')\n  }\n  /** @type {Handle} */\n\n  function onentersetextheading() {\n    buffer()\n    setData('slurpAllLineEndings')\n  }\n  /** @type {Handle} */\n\n  function onexitsetextheadingtext() {\n    setData('slurpAllLineEndings', true)\n  }\n  /** @type {Handle} */\n\n  function onexitatxheading() {\n    tag('</h' + getData('headingRank') + '>')\n    setData('headingRank')\n  }\n  /** @type {Handle} */\n\n  function onexitsetextheadinglinesequence(token) {\n    setData(\n      'headingRank',\n      this.sliceSerialize(token).charCodeAt(0) === 61 ? 1 : 2\n    )\n  }\n  /** @type {Handle} */\n\n  function onexitsetextheading() {\n    const value = resume()\n    lineEndingIfNeeded()\n    tag('<h' + getData('headingRank') + '>')\n    raw(value)\n    tag('</h' + getData('headingRank') + '>')\n    setData('slurpAllLineEndings')\n    setData('headingRank')\n  }\n  /** @type {Handle} */\n\n  function onexitdata(token) {\n    raw(encode(this.sliceSerialize(token)))\n  }\n  /** @type {Handle} */\n\n  function onexitlineending(token) {\n    if (getData('slurpAllLineEndings')) {\n      return\n    }\n\n    if (getData('slurpOneLineEnding')) {\n      setData('slurpOneLineEnding')\n      return\n    }\n\n    if (getData('inCodeText')) {\n      raw(' ')\n      return\n    }\n\n    raw(encode(this.sliceSerialize(token)))\n  }\n  /** @type {Handle} */\n\n  function onexitcodeflowvalue(token) {\n    raw(encode(this.sliceSerialize(token)))\n    setData('flowCodeSeenData', true)\n  }\n  /** @type {Handle} */\n\n  function onexithardbreak() {\n    tag('<br />')\n  }\n  /** @type {Handle} */\n\n  function onenterhtmlflow() {\n    lineEndingIfNeeded()\n    onenterhtml()\n  }\n  /** @type {Handle} */\n\n  function onexithtml() {\n    setData('ignoreEncode')\n  }\n  /** @type {Handle} */\n\n  function onenterhtml() {\n    if (options.allowDangerousHtml) {\n      setData('ignoreEncode', true)\n    }\n  }\n  /** @type {Handle} */\n\n  function onenteremphasis() {\n    tag('<em>')\n  }\n  /** @type {Handle} */\n\n  function onenterstrong() {\n    tag('<strong>')\n  }\n  /** @type {Handle} */\n\n  function onentercodetext() {\n    setData('inCodeText', true)\n    tag('<code>')\n  }\n  /** @type {Handle} */\n\n  function onexitcodetext() {\n    setData('inCodeText')\n    tag('</code>')\n  }\n  /** @type {Handle} */\n\n  function onexitemphasis() {\n    tag('</em>')\n  }\n  /** @type {Handle} */\n\n  function onexitstrong() {\n    tag('</strong>')\n  }\n  /** @type {Handle} */\n\n  function onexitthematicbreak() {\n    lineEndingIfNeeded()\n    tag('<hr />')\n  }\n  /** @type {Handle} */\n\n  function onexitcharacterreferencemarker(token) {\n    setData('characterReferenceType', token.type)\n  }\n  /** @type {Handle} */\n\n  function onexitcharacterreferencevalue(token) {\n    let value = this.sliceSerialize(token) // @ts-expect-error `decodeEntity` can return false for invalid named\n    // character references, but everything we’ve tokenized is valid.\n\n    value = getData('characterReferenceType')\n      ? decodeNumericCharacterReference(\n          value,\n          getData('characterReferenceType') ===\n            'characterReferenceMarkerNumeric'\n            ? 10\n            : 16\n        )\n      : decodeEntity(value)\n    raw(encode(value))\n    setData('characterReferenceType')\n  }\n  /** @type {Handle} */\n\n  function onexitautolinkprotocol(token) {\n    const uri = this.sliceSerialize(token)\n    tag(\n      '<a href=\"' +\n        sanitizeUri(\n          uri,\n          options.allowDangerousProtocol ? undefined : protocolHref\n        ) +\n        '\">'\n    )\n    raw(encode(uri))\n    tag('</a>')\n  }\n  /** @type {Handle} */\n\n  function onexitautolinkemail(token) {\n    const uri = this.sliceSerialize(token)\n    tag('<a href=\"' + sanitizeUri('mailto:' + uri) + '\">')\n    raw(encode(uri))\n    tag('</a>')\n  }\n}\n"],"names":["hasOwnProperty","protocolHref","protocolSrc","options","tags","definitions","buffers","mediaStack","tightStack","defaultHandlers","enter","blockQuote","push","lineEndingIfNeeded","tag","codeFenced","setData","codeFencedFenceInfo","buffer","codeFencedFenceMeta","codeIndented","codeText","content","definition","definitionDestinationString","definitionLabelString","definitionTitleString","emphasis","htmlFlow","onenterhtml","htmlText","image","undefined","label","link","listItemMarker","getData","onexitlistitem","listItemValue","token","value","Number","parseInt","this","sliceSerialize","encode","String","listOrdered","_loose","listUnordered","paragraph","length","reference","resource","destination","resourceDestinationString","resourceTitleString","setextHeading","strong","exit","atxHeading","atxHeadingSequence","autolinkEmail","uri","sanitizeUri","raw","autolinkProtocol","allowDangerousProtocol","pop","characterEscapeValue","onexitdata","characterReferenceMarkerHexadecimal","onexitcharacterreferencemarker","characterReferenceMarkerNumeric","characterReferenceValue","decodeNumericCharacterReference","decodeEntity","onexitflowcode","codeFencedFence","count","resume","codeFlowValue","codeTextData","data","media","id","normalizeIdentifier","labelId","call","title","hardBreakEscape","onexithardbreak","hardBreakTrailing","onexithtml","htmlFlowData","htmlTextData","onexitmedia","labelText","lineEnding","referenceString","referenceId","setextHeadingLineSequence","charCodeAt","setextHeadingText","thematicBreak","handlers","combineHtmlExtensions","concat","htmlExtensions","context","lineEndingStyle","defaultLineEnding","events","index","start","listStack","head","body","type","prepareList","slice","result","null","handler","Object","assign","join","atMarker","containerBalance","loose","event","_container","key","previous","_encode","allowDangerousHtml"],"mappings":"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"}