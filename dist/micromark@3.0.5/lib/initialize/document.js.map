{"version":3,"file":"document.js","sources":["../../../../node_modules/micromark/lib/initialize/document.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').InitialConstruct} InitialConstruct\n * @typedef {import('micromark-util-types').Initializer} Initializer\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Point} Point\n */\n\n/**\n * @typedef {Record<string, unknown>} StackState\n * @typedef {[Construct, StackState]} StackItem\n */\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEnding} from 'micromark-util-character'\nimport {splice} from 'micromark-util-chunked'\n/** @type {InitialConstruct} */\n\nexport const document = {\n  tokenize: initializeDocument\n}\n/** @type {Construct} */\n\nconst containerConstruct = {\n  tokenize: tokenizeContainer\n}\n/** @type {Initializer} */\n\nfunction initializeDocument(effects) {\n  const self = this\n  /** @type {StackItem[]} */\n\n  const stack = []\n  let continued = 0\n  /** @type {TokenizeContext|undefined} */\n\n  let childFlow\n  /** @type {Token|undefined} */\n\n  let childToken\n  /** @type {number} */\n\n  let lineStartOffset\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    // First we iterate through the open blocks, starting with the root\n    // document, and descending through last children down to the last open\n    // block.\n    // Each block imposes a condition that the line must satisfy if the block is\n    // to remain open.\n    // For example, a block quote requires a `>` character.\n    // A paragraph requires a non-blank line.\n    // In this phase we may match all or just some of the open blocks.\n    // But we cannot close unmatched blocks yet, because we may have a lazy\n    // continuation line.\n    if (continued < stack.length) {\n      const item = stack[continued]\n      self.containerState = item[1]\n      return effects.attempt(\n        item[0].continuation,\n        documentContinue,\n        checkNewContainers\n      )(code)\n    } // Done.\n\n    return checkNewContainers(code)\n  }\n  /** @type {State} */\n\n  function documentContinue(code) {\n    continued++ // Note: this field is called `_closeFlow` but it also closes containers.\n    // Perhaps a good idea to rename it but it’s already used in the wild by\n    // extensions.\n\n    if (self.containerState._closeFlow) {\n      self.containerState._closeFlow = undefined\n\n      if (childFlow) {\n        closeFlow()\n      } // Note: this algorithm for moving events around is similar to the\n      // algorithm when dealing with lazy lines in `writeToChild`.\n\n      const indexBeforeExits = self.events.length\n      let indexBeforeFlow = indexBeforeExits\n      /** @type {Point|undefined} */\n\n      let point // Find the flow chunk.\n\n      while (indexBeforeFlow--) {\n        if (\n          self.events[indexBeforeFlow][0] === 'exit' &&\n          self.events[indexBeforeFlow][1].type === 'chunkFlow'\n        ) {\n          point = self.events[indexBeforeFlow][1].end\n          break\n        }\n      }\n\n      exitContainers(continued) // Fix positions.\n\n      let index = indexBeforeExits\n\n      while (index < self.events.length) {\n        self.events[index][1].end = Object.assign({}, point)\n        index++\n      } // Inject the exits earlier (they’re still also at the end).\n\n      splice(\n        self.events,\n        indexBeforeFlow + 1,\n        0,\n        self.events.slice(indexBeforeExits)\n      ) // Discard the duplicate exits.\n\n      self.events.length = index\n      return checkNewContainers(code)\n    }\n\n    return start(code)\n  }\n  /** @type {State} */\n\n  function checkNewContainers(code) {\n    // Next, after consuming the continuation markers for existing blocks, we\n    // look for new block starts (e.g. `>` for a block quote).\n    // If we encounter a new block start, we close any blocks unmatched in\n    // step 1 before creating the new block as a child of the last matched\n    // block.\n    if (continued === stack.length) {\n      // No need to `check` whether there’s a container, of `exitContainers`\n      // would be moot.\n      // We can instead immediately `attempt` to parse one.\n      if (!childFlow) {\n        return documentContinued(code)\n      } // If we have concrete content, such as block HTML or fenced code,\n      // we can’t have containers “pierce” into them, so we can immediately\n      // start.\n\n      if (childFlow.currentConstruct && childFlow.currentConstruct.concrete) {\n        return flowStart(code)\n      } // If we do have flow, it could still be a blank line,\n      // but we’d be interrupting it w/ a new container if there’s a current\n      // construct.\n\n      self.interrupt = Boolean(childFlow.currentConstruct)\n    } // Check if there is a new container.\n\n    self.containerState = {}\n    return effects.check(\n      containerConstruct,\n      thereIsANewContainer,\n      thereIsNoNewContainer\n    )(code)\n  }\n  /** @type {State} */\n\n  function thereIsANewContainer(code) {\n    if (childFlow) closeFlow()\n    exitContainers(continued)\n    return documentContinued(code)\n  }\n  /** @type {State} */\n\n  function thereIsNoNewContainer(code) {\n    self.parser.lazy[self.now().line] = continued !== stack.length\n    lineStartOffset = self.now().offset\n    return flowStart(code)\n  }\n  /** @type {State} */\n\n  function documentContinued(code) {\n    // Try new containers.\n    self.containerState = {}\n    return effects.attempt(\n      containerConstruct,\n      containerContinue,\n      flowStart\n    )(code)\n  }\n  /** @type {State} */\n\n  function containerContinue(code) {\n    continued++\n    stack.push([self.currentConstruct, self.containerState]) // Try another.\n\n    return documentContinued(code)\n  }\n  /** @type {State} */\n\n  function flowStart(code) {\n    if (code === null) {\n      if (childFlow) closeFlow()\n      exitContainers(0)\n      effects.consume(code)\n      return\n    }\n\n    childFlow = childFlow || self.parser.flow(self.now())\n    effects.enter('chunkFlow', {\n      contentType: 'flow',\n      previous: childToken,\n      _tokenizer: childFlow\n    })\n    return flowContinue(code)\n  }\n  /** @type {State} */\n\n  function flowContinue(code) {\n    if (code === null) {\n      writeToChild(effects.exit('chunkFlow'), true)\n      exitContainers(0)\n      effects.consume(code)\n      return\n    }\n\n    if (markdownLineEnding(code)) {\n      effects.consume(code)\n      writeToChild(effects.exit('chunkFlow')) // Get ready for the next line.\n\n      continued = 0\n      self.interrupt = undefined\n      return start\n    }\n\n    effects.consume(code)\n    return flowContinue\n  }\n  /**\n   * @param {Token} token\n   * @param {boolean} [eof]\n   * @returns {void}\n   */\n\n  function writeToChild(token, eof) {\n    const stream = self.sliceStream(token)\n    if (eof) stream.push(null)\n    token.previous = childToken\n    if (childToken) childToken.next = token\n    childToken = token\n    childFlow.defineSkip(token.start)\n    childFlow.write(stream) // Alright, so we just added a lazy line:\n    //\n    // ```markdown\n    // > a\n    // b.\n    //\n    // Or:\n    //\n    // > ~~~c\n    // d\n    //\n    // Or:\n    //\n    // > | e |\n    // f\n    // ```\n    //\n    // The construct in the second example (fenced code) does not accept lazy\n    // lines, so it marked itself as done at the end of its first line, and\n    // then the content construct parses `d`.\n    // Most constructs in markdown match on the first line: if the first line\n    // forms a construct, a non-lazy line can’t “unmake” it.\n    //\n    // The construct in the third example is potentially a GFM table, and\n    // those are *weird*.\n    // It *could* be a table, from the first line, if the following line\n    // matches a condition.\n    // In this case, that second line is lazy, which “unmakes” the first line\n    // and turns the whole into one content block.\n    //\n    // We’ve now parsed the non-lazy and the lazy line, and can figure out\n    // whether the lazy line started a new flow block.\n    // If it did, we exit the current containers between the two flow blocks.\n\n    if (self.parser.lazy[token.start.line]) {\n      let index = childFlow.events.length\n\n      while (index--) {\n        if (\n          // The token starts before the line ending…\n          childFlow.events[index][1].start.offset < lineStartOffset && // …and either is not ended yet…\n          (!childFlow.events[index][1].end || // …or ends after it.\n            childFlow.events[index][1].end.offset > lineStartOffset)\n        ) {\n          // Exit: there’s still something open, which means it’s a lazy line\n          // part of something.\n          return\n        }\n      } // Note: this algorithm for moving events around is similar to the\n      // algorithm when closing flow in `documentContinue`.\n\n      const indexBeforeExits = self.events.length\n      let indexBeforeFlow = indexBeforeExits\n      /** @type {boolean|undefined} */\n\n      let seen\n      /** @type {Point|undefined} */\n\n      let point // Find the previous chunk (the one before the lazy line).\n\n      while (indexBeforeFlow--) {\n        if (\n          self.events[indexBeforeFlow][0] === 'exit' &&\n          self.events[indexBeforeFlow][1].type === 'chunkFlow'\n        ) {\n          if (seen) {\n            point = self.events[indexBeforeFlow][1].end\n            break\n          }\n\n          seen = true\n        }\n      }\n\n      exitContainers(continued) // Fix positions.\n\n      index = indexBeforeExits\n\n      while (index < self.events.length) {\n        self.events[index][1].end = Object.assign({}, point)\n        index++\n      } // Inject the exits earlier (they’re still also at the end).\n\n      splice(\n        self.events,\n        indexBeforeFlow + 1,\n        0,\n        self.events.slice(indexBeforeExits)\n      ) // Discard the duplicate exits.\n\n      self.events.length = index\n    }\n  }\n  /**\n   * @param {number} size\n   * @returns {void}\n   */\n\n  function exitContainers(size) {\n    let index = stack.length // Exit open containers.\n\n    while (index-- > size) {\n      const entry = stack[index]\n      self.containerState = entry[1]\n      entry[0].exit.call(self, effects)\n    }\n\n    stack.length = size\n  }\n\n  function closeFlow() {\n    childFlow.write([null])\n    childToken = undefined\n    childFlow = undefined\n    self.containerState._closeFlow = undefined\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeContainer(effects, ok, nok) {\n  return factorySpace(\n    effects,\n    effects.attempt(this.parser.constructs.document, ok, nok),\n    'linePrefix',\n    this.parser.constructs.disable.null.includes('codeIndented') ? undefined : 4\n  )\n}\n"],"names":["document","tokenize","effects","self","this","stack","childFlow","childToken","lineStartOffset","continued","start","code","length","item","containerState","attempt","continuation","documentContinue","checkNewContainers","_closeFlow","undefined","closeFlow","indexBeforeExits","events","point","indexBeforeFlow","type","end","exitContainers","index","Object","assign","splice","slice","documentContinued","currentConstruct","concrete","flowStart","interrupt","Boolean","check","containerConstruct","thereIsANewContainer","thereIsNoNewContainer","parser","lazy","now","line","offset","containerContinue","push","consume","flow","enter","contentType","previous","_tokenizer","flowContinue","writeToChild","exit","markdownLineEnding","token","eof","stream","sliceStream","next","defineSkip","write","seen","size","entry","call","ok","nok","factorySpace","constructs","disable","null","includes"],"mappings":"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"}