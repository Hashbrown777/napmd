{"version":3,"file":"text.js","sources":["../../../../node_modules/micromark/lib/initialize/text.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Initializer} Initializer\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').InitialConstruct} InitialConstruct\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Code} Code\n */\nexport const resolver = {\n  resolveAll: createResolver()\n}\nexport const string = initializeFactory('string')\nexport const text = initializeFactory('text')\n/**\n * @param {'string'|'text'} field\n * @returns {InitialConstruct}\n */\n\nfunction initializeFactory(field) {\n  return {\n    tokenize: initializeText,\n    resolveAll: createResolver(\n      field === 'text' ? resolveAllLineSuffixes : undefined\n    )\n  }\n  /** @type {Initializer} */\n\n  function initializeText(effects) {\n    const self = this\n    const constructs = this.parser.constructs[field]\n    const text = effects.attempt(constructs, start, notText)\n    return start\n    /** @type {State} */\n\n    function start(code) {\n      return atBreak(code) ? text(code) : notText(code)\n    }\n    /** @type {State} */\n\n    function notText(code) {\n      if (code === null) {\n        effects.consume(code)\n        return\n      }\n\n      effects.enter('data')\n      effects.consume(code)\n      return data\n    }\n    /** @type {State} */\n\n    function data(code) {\n      if (atBreak(code)) {\n        effects.exit('data')\n        return text(code)\n      } // Data.\n\n      effects.consume(code)\n      return data\n    }\n    /**\n     * @param {Code} code\n     * @returns {boolean}\n     */\n\n    function atBreak(code) {\n      if (code === null) {\n        return true\n      }\n\n      const list = constructs[code]\n      let index = -1\n\n      if (list) {\n        while (++index < list.length) {\n          const item = list[index]\n\n          if (!item.previous || item.previous.call(self, self.previous)) {\n            return true\n          }\n        }\n      }\n\n      return false\n    }\n  }\n}\n/**\n * @param {Resolver} [extraResolver]\n * @returns {Resolver}\n */\n\nfunction createResolver(extraResolver) {\n  return resolveAllText\n  /** @type {Resolver} */\n\n  function resolveAllText(events, context) {\n    let index = -1\n    /** @type {number|undefined} */\n\n    let enter // A rather boring computation (to merge adjacent `data` events) which\n    // improves mm performance by 29%.\n\n    while (++index <= events.length) {\n      if (enter === undefined) {\n        if (events[index] && events[index][1].type === 'data') {\n          enter = index\n          index++\n        }\n      } else if (!events[index] || events[index][1].type !== 'data') {\n        // Don’t do anything if there is one data token.\n        if (index !== enter + 2) {\n          events[enter][1].end = events[index - 1][1].end\n          events.splice(enter + 2, index - enter - 2)\n          index = enter + 2\n        }\n\n        enter = undefined\n      }\n    }\n\n    return extraResolver ? extraResolver(events, context) : events\n  }\n}\n/**\n * A rather ugly set of instructions which again looks at chunks in the input\n * stream.\n * The reason to do this here is that it is *much* faster to parse in reverse.\n * And that we can’t hook into `null` to split the line suffix before an EOF.\n * To do: figure out if we can make this into a clean utility, or even in core.\n * As it will be useful for GFMs literal autolink extension (and maybe even\n * tables?)\n *\n * @type {Resolver}\n */\n\nfunction resolveAllLineSuffixes(events, context) {\n  let eventIndex = -1\n\n  while (++eventIndex <= events.length) {\n    if (\n      (eventIndex === events.length ||\n        events[eventIndex][1].type === 'lineEnding') &&\n      events[eventIndex - 1][1].type === 'data'\n    ) {\n      const data = events[eventIndex - 1][1]\n      const chunks = context.sliceStream(data)\n      let index = chunks.length\n      let bufferIndex = -1\n      let size = 0\n      /** @type {boolean|undefined} */\n\n      let tabs\n\n      while (index--) {\n        const chunk = chunks[index]\n\n        if (typeof chunk === 'string') {\n          bufferIndex = chunk.length\n\n          while (chunk.charCodeAt(bufferIndex - 1) === 32) {\n            size++\n            bufferIndex--\n          }\n\n          if (bufferIndex) break\n          bufferIndex = -1\n        } // Number\n        else if (chunk === -2) {\n          tabs = true\n          size++\n        } else if (chunk === -1) {\n          // Empty\n        } else {\n          // Replacement character, exit.\n          index++\n          break\n        }\n      }\n\n      if (size) {\n        const token = {\n          type:\n            eventIndex === events.length || tabs || size < 2\n              ? 'lineSuffix'\n              : 'hardBreakTrailing',\n          start: {\n            line: data.end.line,\n            column: data.end.column - size,\n            offset: data.end.offset - size,\n            _index: data.start._index + index,\n            _bufferIndex: index\n              ? bufferIndex\n              : data.start._bufferIndex + bufferIndex\n          },\n          end: Object.assign({}, data.end)\n        }\n        data.end = Object.assign({}, token.start)\n\n        if (data.start.offset === data.end.offset) {\n          Object.assign(data, token)\n        } else {\n          events.splice(\n            eventIndex,\n            0,\n            ['enter', token, context],\n            ['exit', token, context]\n          )\n          eventIndex += 2\n        }\n      }\n\n      eventIndex++\n    }\n  }\n\n  return events\n}\n"],"names":["resolver","resolveAll","createResolver","string","initializeFactory","text","field","tokenize","effects","self","this","constructs","parser","attempt","start","notText","code","atBreak","enter","consume","data","exit","list","index","length","item","previous","call","resolveAllLineSuffixes","undefined","extraResolver","events","context","type","end","splice","eventIndex","chunks","sliceStream","tabs","bufferIndex","size","chunk","charCodeAt","token","line","column","offset","_index","_bufferIndex","Object","assign"],"mappings":"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"}