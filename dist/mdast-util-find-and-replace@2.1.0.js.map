{"version":3,"file":"mdast-util-find-and-replace@2.1.0.js","sources":["../node_modules/mdast-util-find-and-replace/index.js"],"sourcesContent":["/**\n * @typedef Options Configuration.\n * @property {Test} [ignore] `unist-util-is` test used to assert parents\n *\n * @typedef {import('mdast').Root} Root\n * @typedef {import('mdast').Content} Content\n * @typedef {import('mdast').PhrasingContent} PhrasingContent\n * @typedef {import('mdast').Text} Text\n * @typedef {Content|Root} Node\n * @typedef {Extract<Node, import('mdast').Parent>} Parent\n *\n * @typedef {import('unist-util-visit-parents').Test} Test\n * @typedef {import('unist-util-visit-parents').VisitorResult} VisitorResult\n *\n * @typedef RegExpMatchObject\n * @property {number} index\n * @property {string} input\n *\n * @typedef {string|RegExp} Find\n * @typedef {string|ReplaceFunction} Replace\n *\n * @typedef {[Find, Replace]} FindAndReplaceTuple\n * @typedef {Object.<string, Replace>} FindAndReplaceSchema\n * @typedef {Array.<FindAndReplaceTuple>} FindAndReplaceList\n *\n * @typedef {[RegExp, ReplaceFunction]} Pair\n * @typedef {Array.<Pair>} Pairs\n */\n\n/**\n * @callback ReplaceFunction\n * @param {...any} parameters\n * @returns {Array.<PhrasingContent>|PhrasingContent|string|false|undefined|null}\n */\n\nimport escape from 'escape-string-regexp'\nimport {visitParents} from 'unist-util-visit-parents'\nimport {convert} from 'unist-util-is'\n\nconst own = {}.hasOwnProperty\n\n/**\n * @param tree mdast tree\n * @param find Value to find and remove. When `string`, escaped and made into a global `RegExp`\n * @param [replace] Value to insert.\n *   * When `string`, turned into a Text node.\n *   * When `Function`, called with the results of calling `RegExp.exec` as\n *     arguments, in which case it can return a single or a list of `Node`,\n *     a `string` (which is wrapped in a `Text` node), or `false` to not replace\n * @param [options] Configuration.\n */\nexport const findAndReplace =\n  /**\n   * @type {(\n   *   ((tree: Node, find: Find, replace?: Replace, options?: Options) => Node) &\n   *   ((tree: Node, schema: FindAndReplaceSchema|FindAndReplaceList, options?: Options) => Node)\n   * )}\n   **/\n  (\n    /**\n     * @param {Node} tree\n     * @param {Find|FindAndReplaceSchema|FindAndReplaceList} find\n     * @param {Replace|Options} [replace]\n     * @param {Options} [options]\n     */\n    function (tree, find, replace, options) {\n      /** @type {Options|undefined} */\n      let settings\n      /** @type {FindAndReplaceSchema|FindAndReplaceList} */\n      let schema\n\n      if (typeof find === 'string' || find instanceof RegExp) {\n        // @ts-expect-error don’t expect options twice.\n        schema = [[find, replace]]\n        settings = options\n      } else {\n        schema = find\n        // @ts-expect-error don’t expect replace twice.\n        settings = replace\n      }\n\n      if (!settings) {\n        settings = {}\n      }\n\n      const ignored = convert(settings.ignore || [])\n      const pairs = toPairs(schema)\n      let pairIndex = -1\n\n      while (++pairIndex < pairs.length) {\n        visitParents(tree, 'text', visitor)\n      }\n\n      return tree\n\n      /** @type {import('unist-util-visit-parents').Visitor<Text>} */\n      function visitor(node, parents) {\n        let index = -1\n        /** @type {Parent|undefined} */\n        let grandparent\n\n        while (++index < parents.length) {\n          const parent = /** @type {Parent} */ (parents[index])\n\n          if (\n            ignored(\n              parent,\n              // @ts-expect-error mdast vs. unist parent.\n              grandparent ? grandparent.children.indexOf(parent) : undefined,\n              grandparent\n            )\n          ) {\n            return\n          }\n\n          grandparent = parent\n        }\n\n        if (grandparent) {\n          return handler(node, grandparent)\n        }\n      }\n\n      /**\n       * @param {Text} node\n       * @param {Parent} parent\n       * @returns {VisitorResult}\n       */\n      function handler(node, parent) {\n        const find = pairs[pairIndex][0]\n        const replace = pairs[pairIndex][1]\n        let start = 0\n        // @ts-expect-error: TS is wrong, some of these children can be text.\n        let index = parent.children.indexOf(node)\n        /** @type {Array.<PhrasingContent>} */\n        let nodes = []\n        /** @type {number|undefined} */\n        let position\n\n        find.lastIndex = 0\n\n        let match = find.exec(node.value)\n\n        while (match) {\n          position = match.index\n          // @ts-expect-error this is perfectly fine, typescript.\n          let value = replace(...match, {\n            index: match.index,\n            input: match.input\n          })\n\n          if (typeof value === 'string') {\n            value = value.length > 0 ? {type: 'text', value} : undefined\n          }\n\n          if (value !== false) {\n            if (start !== position) {\n              nodes.push({\n                type: 'text',\n                value: node.value.slice(start, position)\n              })\n            }\n\n            if (Array.isArray(value)) {\n              nodes.push(...value)\n            } else if (value) {\n              nodes.push(value)\n            }\n\n            start = position + match[0].length\n          }\n\n          if (!find.global) {\n            break\n          }\n\n          match = find.exec(node.value)\n        }\n\n        if (position === undefined) {\n          nodes = [node]\n          index--\n        } else {\n          if (start < node.value.length) {\n            nodes.push({type: 'text', value: node.value.slice(start)})\n          }\n\n          parent.children.splice(index, 1, ...nodes)\n        }\n\n        return index + nodes.length + 1\n      }\n    }\n  )\n\n/**\n * @param {FindAndReplaceSchema|FindAndReplaceList} schema\n * @returns {Pairs}\n */\nfunction toPairs(schema) {\n  /** @type {Pairs} */\n  const result = []\n\n  if (typeof schema !== 'object') {\n    throw new TypeError('Expected array or object as schema')\n  }\n\n  if (Array.isArray(schema)) {\n    let index = -1\n\n    while (++index < schema.length) {\n      result.push([\n        toExpression(schema[index][0]),\n        toFunction(schema[index][1])\n      ])\n    }\n  } else {\n    /** @type {string} */\n    let key\n\n    for (key in schema) {\n      if (own.call(schema, key)) {\n        result.push([toExpression(key), toFunction(schema[key])])\n      }\n    }\n  }\n\n  return result\n}\n\n/**\n * @param {Find} find\n * @returns {RegExp}\n */\nfunction toExpression(find) {\n  return typeof find === 'string' ? new RegExp(escape(find), 'g') : find\n}\n\n/**\n * @param {Replace} replace\n * @returns {ReplaceFunction}\n */\nfunction toFunction(replace) {\n  return typeof replace === 'function' ? replace : () => replace\n}\n"],"names":["own","hasOwnProperty","toExpression","find","RegExp","escape","toFunction","replace","tree","options","settings","schema","ignored","convert","ignore","pairs","result","TypeError","Array","isArray","index","length","push","key","call","toPairs","pairIndex","visitParents","visitor","node","parents","grandparent","parent","children","indexOf","undefined","position","start","nodes","lastIndex","match","exec","value","input","type","slice","global","splice","handler"],"mappings":"2LAuCA,MAAMA,EAAM,GAAGC,eAmMf,SAASC,EAAaC,GACpB,MAAuB,iBAATA,EAAoB,IAAIC,OAAOC,UAAOF,GAAO,KAAOA,EAOpE,SAASG,EAAWC,GAClB,MAA0B,mBAAZA,EAAyBA,EAAU,IAAMA,4BAlL3CC,EAAML,EAAMI,EAASE,GAE7B,IAAIC,EAEAC,EAEgB,iBAATR,GAAqBA,aAAgBC,QAE9CO,EAAS,CAAC,CAACR,EAAMI,IACjBG,EAAWD,IAEXE,EAASR,EAETO,EAAWH,GAGRG,IACHA,EAAW,IAGb,MAAME,EAAUC,UAAQH,EAASI,QAAU,IACrCC,EAiHZ,SAAiBJ,GAEf,MAAMK,EAAS,GAEf,GAAsB,iBAAXL,EACT,MAAM,IAAIM,UAAU,sCAGtB,GAAIC,MAAMC,QAAQR,GAAS,CACzB,IAAIS,GAAS,EAEb,OAASA,EAAQT,EAAOU,QACtBL,EAAOM,KAAK,CACVpB,EAAaS,EAAOS,GAAO,IAC3Bd,EAAWK,EAAOS,GAAO,UAGxB,CAEL,IAAIG,EAEJ,IAAKA,KAAOZ,EACNX,EAAIwB,KAAKb,EAAQY,IACnBP,EAAOM,KAAK,CAACpB,EAAaqB,GAAMjB,EAAWK,EAAOY,MAKxD,OAAOP,EA7IWS,CAAQd,GACtB,IAAIe,GAAa,EAEjB,OAASA,EAAYX,EAAMM,QACzBM,eAAanB,EAAM,OAAQoB,GAG7B,OAAOpB,EAGP,SAASoB,EAAQC,EAAMC,GACrB,IAEIC,EAFAX,GAAS,EAIb,OAASA,EAAQU,EAAQT,QAAQ,CAC/B,MAAMW,EAAgCF,EAAQV,GAE9C,GACER,EACEoB,EAEAD,EAAcA,EAAYE,SAASC,QAAQF,QAAUG,EACrDJ,GAGF,OAGFA,EAAcC,EAGhB,GAAID,EACF,OASJ,SAAiBF,EAAMG,GACrB,MAAM7B,EAAOY,EAAMW,GAAW,GACxBnB,EAAUQ,EAAMW,GAAW,GACjC,IAMIU,EANAC,EAAQ,EAERjB,EAAQY,EAAOC,SAASC,QAAQL,GAEhCS,EAAQ,GAIZnC,EAAKoC,UAAY,EAEjB,IAAIC,EAAQrC,EAAKsC,KAAKZ,EAAKa,OAE3B,KAAOF,GAAO,CACZJ,EAAWI,EAAMpB,MAEjB,IAAIsB,EAAQnC,KAAWiC,EAAO,CAC5BpB,MAAOoB,EAAMpB,MACbuB,MAAOH,EAAMG,QAwBf,GArBqB,iBAAVD,IACTA,EAAQA,EAAMrB,OAAS,EAAI,CAACuB,KAAM,OAAQF,MAAAA,QAASP,IAGvC,IAAVO,IACEL,IAAUD,GACZE,EAAMhB,KAAK,CACTsB,KAAM,OACNF,MAAOb,EAAKa,MAAMG,MAAMR,EAAOD,KAI/BlB,MAAMC,QAAQuB,GAChBJ,EAAMhB,QAAQoB,GACLA,GACTJ,EAAMhB,KAAKoB,GAGbL,EAAQD,EAAWI,EAAM,GAAGnB,SAGzBlB,EAAK2C,OACR,MAGFN,EAAQrC,EAAKsC,KAAKZ,EAAKa,YAGRP,IAAbC,GACFE,EAAQ,CAACT,GACTT,MAEIiB,EAAQR,EAAKa,MAAMrB,QACrBiB,EAAMhB,KAAK,CAACsB,KAAM,OAAQF,MAAOb,EAAKa,MAAMG,MAAMR,KAGpDL,EAAOC,SAASc,OAAO3B,EAAO,KAAMkB,IAGtC,OAAOlB,EAAQkB,EAAMjB,OAAS,EAvErB2B,CAAQnB,EAAME"}